var Mn = Object.defineProperty;
var Dn = (e, t, l) => t in e ? Mn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l;
var Fe = (e, t, l) => (Dn(e, typeof t != "symbol" ? t + "" : t, l), l);
import { unref as g, computed as w, ref as R, shallowRef as Na, watch as re, getCurrentScope as Kl, onScopeDispose as Jl, shallowReadonly as wt, watchEffect as Ot, readonly as Ee, effectScope as Yl, isRef as La, toRef as N, customRef as jn, getCurrentInstance as Et, onMounted as Ze, nextTick as _e, reactive as It, defineComponent as x, h as ge, Teleport as sa, toValue as Qe, onActivated as qn, onBeforeUnmount as Ia, openBlock as p, createElementBlock as P, Fragment as ve, createElementVNode as Z, renderSlot as A, createVNode as be, withCtx as D, mergeProps as le, normalizeClass as z, normalizeStyle as xe, createTextVNode as ie, toDisplayString as J, createCommentVNode as K, createApp as Gn, provide as Ue, createBlock as M, resolveDynamicComponent as ne, inject as Le, Transition as Wn, normalizeProps as Ve, guardReactiveProps as Pe, useSlots as Oe, useAttrs as Zl, renderList as he, TransitionGroup as Un, withDirectives as vt, vShow as ra, withModifiers as Ha, vModelCheckbox as Xn, vModelRadio as Kn, vModelSelect as Jn, createSlots as za } from "vue";
const Ql = (e) => typeof e == "boolean" || e === "" || e === "true" || e === "false", ia = (e) => typeof e == "boolean" ? e : e === "" || e === "true";
class ot {
  constructor(t, l = {}) {
    Fe(this, "cancelable", !0);
    Fe(this, "componentId", null);
    Fe(this, "_defaultPrevented", !1);
    Fe(this, "eventType", "");
    Fe(this, "nativeEvent", null);
    Fe(this, "_preventDefault");
    Fe(this, "relatedTarget", null);
    Fe(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, ot.Defaults, l, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class Ft extends ot {
  constructor(l, a = {}) {
    super(l, a);
    Fe(this, "trigger", null);
    Object.assign(this, ot.Defaults, a, { eventType: l });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class eo extends ot {
  constructor(l, a) {
    super(l, a);
    Fe(this, "from");
    Fe(this, "to");
    Fe(this, "direction");
    Object.assign(this, ot.Defaults, a, { eventType: l });
    const { from: o, direction: n, to: s } = a;
    this.from = o, this.to = s, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const Sa = (e) => e !== null && typeof e == "object", Yn = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e)), Zn = (e) => Object.prototype.toString.call(e) === "[object Object]", to = /_/g, ao = /([a-z])([A-Z])/g, Qn = /(\s|^)(\w)/g, es = /(\s|^)(\w)/, Xt = /\s+/, ts = /^#/, as = /^#[A-Za-z]+[\w\-:.]*$/, ls = /-u-.+/, os = /[-/\\^$*+?.()|[\]{}]/g, ns = /[\s\uFEFF\xA0]+/g, Yt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || Zn(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), rl = (e) => e.replace(to, " ").replace(ao, (t, l, a) => `${l} ${a}`).replace(es, (t, l, a) => l + a.toUpperCase()), il = (e) => e.replace(to, " ").replace(ao, (t, l, a) => `${l} ${a}`).replace(Qn, (t, l, a) => l + a.toUpperCase()), ss = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
}, rs = (e) => e.replace(os, "\\$&"), is = (e) => rs(e).replace(ns, "\\s"), ya = (e) => `\\${e}`, us = (e) => {
  const t = Yt(e), { length: l } = t, a = t.charCodeAt(0);
  return t.split("").reduce((o, n, s) => {
    const r = t.charCodeAt(s);
    return r === 0 ? `${o}ï¿½` : (
      // ... is U+007F OR
      r === 127 || // ... is in the range [\1-\1F] (U+0001 to U+001F) OR ...
      r >= 1 && r <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...
      s === 0 && r >= 48 && r <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D) ...
      s === 1 && r >= 48 && r <= 57 && a === 45 ? o + ya(`${r.toString(16)} `) : (
        // ... is the first character AND ...
        s === 0 && // ... is a `-` (U+002D) AND ...
        r === 45 && // ... there is no second character ...
        l === 1 ? o + ya(n) : (
          // ... is greater than or equal to U+0080 OR ...
          r >= 128 || // ... is `-` (U+002D) OR ...
          r === 45 || // ... is `_` (U+005F) OR ...
          r === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...
          r >= 48 && r <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...
          r >= 65 && r <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...
          r >= 97 && r <= 122 ? o + n : o + ya(n)
        )
      )
    );
  }, "");
}, lo = typeof window < "u", oo = typeof document < "u", ds = typeof Element < "u", cs = typeof navigator < "u", fs = lo && oo && cs, ul = lo ? window : {}, xa = oo ? document : {};
(() => {
  let e = !1;
  if (fs)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          return e = !0, e;
        }
      };
      ul.addEventListener("test", t, t), ul.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})();
const no = typeof window < "u", vs = typeof document < "u", ps = typeof navigator < "u", Ra = no && vs && ps, dl = no ? window : {}, ms = (() => {
  let e = !1;
  if (Ra)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = !0;
        }
      };
      dl.addEventListener("test", t, t), dl.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})(), He = ds ? Element.prototype : void 0, gs = (He == null ? void 0 : He.matches) || (He == null ? void 0 : He.msMatchesSelector) || (He == null ? void 0 : He.webkitMatchesSelector), et = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), ys = (e) => et(e) ? e.getBoundingClientRect() : null, bs = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((l) => l === t) ? t : null;
}, hs = (e) => et(e) && e === bs(), Bs = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (l) {
    console.error(l);
  }
  return hs(e);
}, Ss = (e, t) => t && et(e) && e.getAttribute(t) || null, ws = (e) => {
  if (Ss(e, "display") === "none")
    return !1;
  const t = ys(e);
  return !!(t && t.height > 0 && t.width > 0);
}, Ae = (e) => ((e == null ? void 0 : e()) ?? []).length === 0, so = (e, t) => (et(t) ? t : xa).querySelector(e) || null, Cs = (e, t) => Array.from([(et(t) ? t : xa).querySelectorAll(e)]), Ma = (e, t) => t && et(e) ? e.getAttribute(t) : null, ks = (e) => xa.getElementById(/^#/.test(e) ? e.slice(1) : e) || null, $s = (e, t, l) => {
  t && et(e) && e.setAttribute(t, l);
}, _s = (e, t) => {
  t && et(e) && e.removeAttribute(t);
}, Ts = (e, t) => Yt(e).toLowerCase() === Yt(t).toLowerCase(), ro = (e, t) => et(e) ? gs.call(e, t) : !1, Vs = (He == null ? void 0 : He.closest) || function(e) {
  let t = this;
  if (!t)
    return null;
  do {
    if (ro(t, e))
      return t;
    t = t.parentElement || t.parentNode;
  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);
  return null;
}, cl = (e, t, l = !1) => {
  if (!et(t))
    return null;
  const a = Vs.call(t, e);
  return l ? a : a === t ? null : a;
}, wa = (e) => {
  const t = window.getComputedStyle(e), l = t.transitionDelay.split(",")[0] || "", a = t.transitionDuration.split(",")[0] || "", o = Number(l.slice(0, -1)) * 1e3, n = Number(a.slice(0, -1)) * 1e3;
  return o + n;
}, ua = (e, t, l) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((a, o) => (a[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = l, a), /* @__PURE__ */ Object.create(null)), io = (e, t, l, a = l) => Object.keys(t).reduce((o, n) => (e[n] && o.push(
  [a, n.replace(l, ""), e[n]].filter((s) => s && typeof s != "boolean").join("-").toLowerCase()
), o), []), mt = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, As = (e) => !!(e.href || e.to), at = (e, t = {}, l = {}) => {
  const a = [e];
  let o;
  for (let n = 0; n < a.length && !o; n++) {
    const s = a[n];
    o = l[s];
  }
  return o && typeof o == "function" ? o(t) : o;
}, gt = (e, t = NaN) => Number.isInteger(e) ? e : t, Os = (e, t = NaN) => {
  const l = Number.parseInt(e, 10);
  return Number.isNaN(l) ? t : l;
}, Kt = (e, t = NaN) => {
  const l = Number.parseFloat(e.toString());
  return Number.isNaN(l) ? t : l;
}, uo = (e, t) => Object.keys(e).filter((l) => !t.map((a) => a.toString()).includes(l)).reduce((l, a) => ({ ...l, [a]: e[a] }), {}), Da = (e, t) => [...t].reduce(
  (l, a) => (l[a] = e[a], l),
  {}
), fl = (e, t, l) => {
  const a = t.split(/[.[\]]/g);
  let o = e;
  for (const n of a) {
    if (o === null || o === void 0)
      return l;
    n.trim() !== "" && (o = o[n]);
  }
  return o === void 0 ? l : o;
}, vl = (e, t) => t + (e ? ss(e) : ""), da = (e, t) => e === !0 || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === !1 ? "true" : e === !1 || e === "false" ? "false" : void 0, co = Symbol("carousel"), fo = Symbol("tabs"), vo = Symbol("progress"), po = Symbol("listGroup"), mo = Symbol("avatarGroup"), go = Symbol("accordion"), yo = Symbol("checkboxGroup"), bo = Symbol("radioGroup"), ja = Symbol("collapse"), ho = Symbol("collapse"), qa = Symbol("navbar"), Ca = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((l, a) => (typeof a.type == "symbol" ? l = l.concat(a.children) : l.push(a), l), []).filter((l) => {
  var a;
  return ((a = l.type) == null ? void 0 : a.__name) === t;
}), Bo = ["top", "right", "bottom", "left"], pl = ["start", "end"], ml = /* @__PURE__ */ Bo.reduce((e, t) => e.concat(t, t + "-" + pl[0], t + "-" + pl[1]), []), nt = Math.min, Ke = Math.max, Zt = Math.round, jt = Math.floor, dt = (e) => ({
  x: e,
  y: e
}), Es = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Fs = {
  start: "end",
  end: "start"
};
function ka(e, t, l) {
  return Ke(e, nt(t, l));
}
function pt(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Ge(e) {
  return e.split("-")[0];
}
function Je(e) {
  return e.split("-")[1];
}
function So(e) {
  return e === "x" ? "y" : "x";
}
function Ga(e) {
  return e === "y" ? "height" : "width";
}
function xt(e) {
  return ["top", "bottom"].includes(Ge(e)) ? "y" : "x";
}
function Wa(e) {
  return So(xt(e));
}
function wo(e, t, l) {
  l === void 0 && (l = !1);
  const a = Je(e), o = Wa(e), n = Ga(o);
  let s = o === "x" ? a === (l ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (s = ea(s)), [s, ea(s)];
}
function Ps(e) {
  const t = ea(e);
  return [Qt(e), t, Qt(t)];
}
function Qt(e) {
  return e.replace(/start|end/g, (t) => Fs[t]);
}
function Ns(e, t, l) {
  const a = ["left", "right"], o = ["right", "left"], n = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return l ? t ? o : a : t ? a : o;
    case "left":
    case "right":
      return t ? n : s;
    default:
      return [];
  }
}
function Ls(e, t, l, a) {
  const o = Je(e);
  let n = Ns(Ge(e), l === "start", a);
  return o && (n = n.map((s) => s + "-" + o), t && (n = n.concat(n.map(Qt)))), n;
}
function ea(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Es[t]);
}
function Is(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Ua(e) {
  return typeof e != "number" ? Is(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Vt(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function gl(e, t, l) {
  let {
    reference: a,
    floating: o
  } = e;
  const n = xt(t), s = Wa(t), r = Ga(s), i = Ge(t), d = n === "y", y = a.x + a.width / 2 - o.width / 2, b = a.y + a.height / 2 - o.height / 2, c = a[r] / 2 - o[r] / 2;
  let h;
  switch (i) {
    case "top":
      h = {
        x: y,
        y: a.y - o.height
      };
      break;
    case "bottom":
      h = {
        x: y,
        y: a.y + a.height
      };
      break;
    case "right":
      h = {
        x: a.x + a.width,
        y: b
      };
      break;
    case "left":
      h = {
        x: a.x - o.width,
        y: b
      };
      break;
    default:
      h = {
        x: a.x,
        y: a.y
      };
  }
  switch (Je(t)) {
    case "start":
      h[s] -= c * (l && d ? -1 : 1);
      break;
    case "end":
      h[s] += c * (l && d ? -1 : 1);
      break;
  }
  return h;
}
const Hs = async (e, t, l) => {
  const {
    placement: a = "bottom",
    strategy: o = "absolute",
    middleware: n = [],
    platform: s
  } = l, r = n.filter(Boolean), i = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let d = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: y,
    y: b
  } = gl(d, a, i), c = a, h = {}, S = 0;
  for (let B = 0; B < r.length; B++) {
    const {
      name: F,
      fn: C
    } = r[B], {
      x: V,
      y: T,
      data: $,
      reset: m
    } = await C({
      x: y,
      y: b,
      initialPlacement: a,
      placement: c,
      strategy: o,
      middlewareData: h,
      rects: d,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (y = V ?? y, b = T ?? b, h = {
      ...h,
      [F]: {
        ...h[F],
        ...$
      }
    }, m && S <= 50) {
      S++, typeof m == "object" && (m.placement && (c = m.placement), m.rects && (d = m.rects === !0 ? await s.getElementRects({
        reference: e,
        floating: t,
        strategy: o
      }) : m.rects), {
        x: y,
        y: b
      } = gl(d, c, i)), B = -1;
      continue;
    }
  }
  return {
    x: y,
    y: b,
    placement: c,
    strategy: o,
    middlewareData: h
  };
};
async function Ht(e, t) {
  var l;
  t === void 0 && (t = {});
  const {
    x: a,
    y: o,
    platform: n,
    rects: s,
    elements: r,
    strategy: i
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: y = "viewport",
    elementContext: b = "floating",
    altBoundary: c = !1,
    padding: h = 0
  } = pt(t, e), S = Ua(h), F = r[c ? b === "floating" ? "reference" : "floating" : b], C = Vt(await n.getClippingRect({
    element: (l = await (n.isElement == null ? void 0 : n.isElement(F))) == null || l ? F : F.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(r.floating)),
    boundary: d,
    rootBoundary: y,
    strategy: i
  })), V = b === "floating" ? {
    ...s.floating,
    x: a,
    y: o
  } : s.reference, T = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(r.floating)), $ = await (n.isElement == null ? void 0 : n.isElement(T)) ? await (n.getScale == null ? void 0 : n.getScale(T)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, m = Vt(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: V,
    offsetParent: T,
    strategy: i
  }) : V);
  return {
    top: (C.top - m.top + S.top) / $.y,
    bottom: (m.bottom - C.bottom + S.bottom) / $.y,
    left: (C.left - m.left + S.left) / $.x,
    right: (m.right - C.right + S.right) / $.x
  };
}
const zs = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: l,
      y: a,
      placement: o,
      rects: n,
      platform: s,
      elements: r
    } = t, {
      element: i,
      padding: d = 0
    } = pt(e, t) || {};
    if (i == null)
      return {};
    const y = Ua(d), b = {
      x: l,
      y: a
    }, c = Wa(o), h = Ga(c), S = await s.getDimensions(i), B = c === "y", F = B ? "top" : "left", C = B ? "bottom" : "right", V = B ? "clientHeight" : "clientWidth", T = n.reference[h] + n.reference[c] - b[c] - n.floating[h], $ = b[c] - n.reference[c], m = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(i));
    let k = m ? m[V] : 0;
    (!k || !await (s.isElement == null ? void 0 : s.isElement(m))) && (k = r.floating[V] || n.floating[h]);
    const f = T / 2 - $ / 2, _ = k / 2 - S[h] / 2 - 1, L = nt(y[F], _), v = nt(y[C], _), I = L, H = k - S[h] - v, O = k / 2 - S[h] / 2 + f, q = ka(I, O, H), X = Je(o) != null && O != q && n.reference[h] / 2 - (O < I ? L : v) - S[h] / 2 < 0 ? O < I ? I - O : H - O : 0;
    return {
      [c]: b[c] - X,
      data: {
        [c]: q,
        centerOffset: O - q + X
      }
    };
  }
});
function xs(e, t, l) {
  return (e ? [...l.filter((o) => Je(o) === e), ...l.filter((o) => Je(o) !== e)] : l.filter((o) => Ge(o) === o)).filter((o) => e ? Je(o) === e || (t ? Qt(o) !== o : !1) : !0);
}
const Rs = function(e) {
  return e === void 0 && (e = {}), {
    name: "autoPlacement",
    options: e,
    async fn(t) {
      var l, a, o;
      const {
        rects: n,
        middlewareData: s,
        placement: r,
        platform: i,
        elements: d
      } = t, {
        crossAxis: y = !1,
        alignment: b,
        allowedPlacements: c = ml,
        autoAlignment: h = !0,
        ...S
      } = pt(e, t), B = b !== void 0 || c === ml ? xs(b || null, h, c) : c, F = await Ht(t, S), C = ((l = s.autoPlacement) == null ? void 0 : l.index) || 0, V = B[C];
      if (V == null)
        return {};
      const T = wo(V, n, await (i.isRTL == null ? void 0 : i.isRTL(d.floating)));
      if (r !== V)
        return {
          reset: {
            placement: B[0]
          }
        };
      const $ = [F[Ge(V)], F[T[0]], F[T[1]]], m = [...((a = s.autoPlacement) == null ? void 0 : a.overflows) || [], {
        placement: V,
        overflows: $
      }], k = B[C + 1];
      if (k)
        return {
          data: {
            index: C + 1,
            overflows: m
          },
          reset: {
            placement: k
          }
        };
      const f = m.map((v) => {
        const I = Je(v.placement);
        return [v.placement, I && y ? (
          // Check along the mainAxis and main crossAxis side.
          v.overflows.slice(0, 2).reduce((H, O) => H + O, 0)
        ) : (
          // Check only the mainAxis.
          v.overflows[0]
        ), v.overflows];
      }).sort((v, I) => v[1] - I[1]), L = ((o = f.filter((v) => v[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        Je(v[0]) ? 2 : 3
      ).every((I) => I <= 0))[0]) == null ? void 0 : o[0]) || f[0][0];
      return L !== r ? {
        data: {
          index: C + 1,
          overflows: m
        },
        reset: {
          placement: L
        }
      } : {};
    }
  };
}, Co = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var l;
      const {
        placement: a,
        middlewareData: o,
        rects: n,
        initialPlacement: s,
        platform: r,
        elements: i
      } = t, {
        mainAxis: d = !0,
        crossAxis: y = !0,
        fallbackPlacements: b,
        fallbackStrategy: c = "bestFit",
        fallbackAxisSideDirection: h = "none",
        flipAlignment: S = !0,
        ...B
      } = pt(e, t), F = Ge(a), C = Ge(s) === s, V = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), T = b || (C || !S ? [ea(s)] : Ps(s));
      !b && h !== "none" && T.push(...Ls(s, S, h, V));
      const $ = [s, ...T], m = await Ht(t, B), k = [];
      let f = ((l = o.flip) == null ? void 0 : l.overflows) || [];
      if (d && k.push(m[F]), y) {
        const I = wo(a, n, V);
        k.push(m[I[0]], m[I[1]]);
      }
      if (f = [...f, {
        placement: a,
        overflows: k
      }], !k.every((I) => I <= 0)) {
        var _, L;
        const I = (((_ = o.flip) == null ? void 0 : _.index) || 0) + 1, H = $[I];
        if (H)
          return {
            data: {
              index: I,
              overflows: f
            },
            reset: {
              placement: H
            }
          };
        let O = (L = f.filter((q) => q.overflows[0] <= 0).sort((q, Q) => q.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!O)
          switch (c) {
            case "bestFit": {
              var v;
              const q = (v = f.map((Q) => [Q.placement, Q.overflows.filter((X) => X > 0).reduce((X, ue) => X + ue, 0)]).sort((Q, X) => Q[1] - X[1])[0]) == null ? void 0 : v[0];
              q && (O = q);
              break;
            }
            case "initialPlacement":
              O = s;
              break;
          }
        if (a !== O)
          return {
            reset: {
              placement: O
            }
          };
      }
      return {};
    }
  };
};
function yl(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function bl(e) {
  return Bo.some((t) => e[t] >= 0);
}
const Ms = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: l
      } = t, {
        strategy: a = "referenceHidden",
        ...o
      } = pt(e, t);
      switch (a) {
        case "referenceHidden": {
          const n = await Ht(t, {
            ...o,
            elementContext: "reference"
          }), s = yl(n, l.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: bl(s)
            }
          };
        }
        case "escaped": {
          const n = await Ht(t, {
            ...o,
            altBoundary: !0
          }), s = yl(n, l.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: bl(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function ko(e) {
  const t = nt(...e.map((n) => n.left)), l = nt(...e.map((n) => n.top)), a = Ke(...e.map((n) => n.right)), o = Ke(...e.map((n) => n.bottom));
  return {
    x: t,
    y: l,
    width: a - t,
    height: o - l
  };
}
function Ds(e) {
  const t = e.slice().sort((o, n) => o.y - n.y), l = [];
  let a = null;
  for (let o = 0; o < t.length; o++) {
    const n = t[o];
    !a || n.y - a.y > a.height / 2 ? l.push([n]) : l[l.length - 1].push(n), a = n;
  }
  return l.map((o) => Vt(ko(o)));
}
const js = function(e) {
  return e === void 0 && (e = {}), {
    name: "inline",
    options: e,
    async fn(t) {
      const {
        placement: l,
        elements: a,
        rects: o,
        platform: n,
        strategy: s
      } = t, {
        padding: r = 2,
        x: i,
        y: d
      } = pt(e, t), y = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(a.reference)) || []), b = Ds(y), c = Vt(ko(y)), h = Ua(r);
      function S() {
        if (b.length === 2 && b[0].left > b[1].right && i != null && d != null)
          return b.find((F) => i > F.left - h.left && i < F.right + h.right && d > F.top - h.top && d < F.bottom + h.bottom) || c;
        if (b.length >= 2) {
          if (xt(l) === "y") {
            const v = b[0], I = b[b.length - 1], H = Ge(l) === "top", O = v.top, q = I.bottom, Q = H ? v.left : I.left, X = H ? v.right : I.right, ue = X - Q, ae = q - O;
            return {
              top: O,
              bottom: q,
              left: Q,
              right: X,
              width: ue,
              height: ae,
              x: Q,
              y: O
            };
          }
          const F = Ge(l) === "left", C = Ke(...b.map((v) => v.right)), V = nt(...b.map((v) => v.left)), T = b.filter((v) => F ? v.left === V : v.right === C), $ = T[0].top, m = T[T.length - 1].bottom, k = V, f = C, _ = f - k, L = m - $;
          return {
            top: $,
            bottom: m,
            left: k,
            right: f,
            width: _,
            height: L,
            x: k,
            y: $
          };
        }
        return c;
      }
      const B = await n.getElementRects({
        reference: {
          getBoundingClientRect: S
        },
        floating: a.floating,
        strategy: s
      });
      return o.reference.x !== B.reference.x || o.reference.y !== B.reference.y || o.reference.width !== B.reference.width || o.reference.height !== B.reference.height ? {
        reset: {
          rects: B
        }
      } : {};
    }
  };
};
async function qs(e, t) {
  const {
    placement: l,
    platform: a,
    elements: o
  } = e, n = await (a.isRTL == null ? void 0 : a.isRTL(o.floating)), s = Ge(l), r = Je(l), i = xt(l) === "y", d = ["left", "top"].includes(s) ? -1 : 1, y = n && i ? -1 : 1, b = pt(t, e);
  let {
    mainAxis: c,
    crossAxis: h,
    alignmentAxis: S
  } = typeof b == "number" ? {
    mainAxis: b,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...b
  };
  return r && typeof S == "number" && (h = r === "end" ? S * -1 : S), i ? {
    x: h * y,
    y: c * d
  } : {
    x: c * d,
    y: h * y
  };
}
const $o = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      const {
        x: l,
        y: a
      } = t, o = await qs(t, e);
      return {
        x: l + o.x,
        y: a + o.y,
        data: o
      };
    }
  };
}, _o = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: l,
        y: a,
        placement: o
      } = t, {
        mainAxis: n = !0,
        crossAxis: s = !1,
        limiter: r = {
          fn: (F) => {
            let {
              x: C,
              y: V
            } = F;
            return {
              x: C,
              y: V
            };
          }
        },
        ...i
      } = pt(e, t), d = {
        x: l,
        y: a
      }, y = await Ht(t, i), b = xt(Ge(o)), c = So(b);
      let h = d[c], S = d[b];
      if (n) {
        const F = c === "y" ? "top" : "left", C = c === "y" ? "bottom" : "right", V = h + y[F], T = h - y[C];
        h = ka(V, h, T);
      }
      if (s) {
        const F = b === "y" ? "top" : "left", C = b === "y" ? "bottom" : "right", V = S + y[F], T = S - y[C];
        S = ka(V, S, T);
      }
      const B = r.fn({
        ...t,
        [c]: h,
        [b]: S
      });
      return {
        ...B,
        data: {
          x: B.x - l,
          y: B.y - a
        }
      };
    }
  };
};
function ct(e) {
  return To(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Ie(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function rt(e) {
  var t;
  return (t = (To(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function To(e) {
  return e instanceof Node || e instanceof Ie(e).Node;
}
function st(e) {
  return e instanceof Element || e instanceof Ie(e).Element;
}
function Ye(e) {
  return e instanceof HTMLElement || e instanceof Ie(e).HTMLElement;
}
function hl(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Ie(e).ShadowRoot;
}
function Rt(e) {
  const {
    overflow: t,
    overflowX: l,
    overflowY: a,
    display: o
  } = Me(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + l) && !["inline", "contents"].includes(o);
}
function Gs(e) {
  return ["table", "td", "th"].includes(ct(e));
}
function Xa(e) {
  const t = Ka(), l = Me(e);
  return l.transform !== "none" || l.perspective !== "none" || (l.containerType ? l.containerType !== "normal" : !1) || !t && (l.backdropFilter ? l.backdropFilter !== "none" : !1) || !t && (l.filter ? l.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((a) => (l.willChange || "").includes(a)) || ["paint", "layout", "strict", "content"].some((a) => (l.contain || "").includes(a));
}
function Ws(e) {
  let t = At(e);
  for (; Ye(t) && !ca(t); ) {
    if (Xa(t))
      return t;
    t = At(t);
  }
  return null;
}
function Ka() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ca(e) {
  return ["html", "body", "#document"].includes(ct(e));
}
function Me(e) {
  return Ie(e).getComputedStyle(e);
}
function fa(e) {
  return st(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function At(e) {
  if (ct(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    hl(e) && e.host || // Fallback.
    rt(e)
  );
  return hl(t) ? t.host : t;
}
function Vo(e) {
  const t = At(e);
  return ca(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Ye(t) && Rt(t) ? t : Vo(t);
}
function ta(e, t) {
  var l;
  t === void 0 && (t = []);
  const a = Vo(e), o = a === ((l = e.ownerDocument) == null ? void 0 : l.body), n = Ie(a);
  return o ? t.concat(n, n.visualViewport || [], Rt(a) ? a : []) : t.concat(a, ta(a));
}
function Ao(e) {
  const t = Me(e);
  let l = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const o = Ye(e), n = o ? e.offsetWidth : l, s = o ? e.offsetHeight : a, r = Zt(l) !== n || Zt(a) !== s;
  return r && (l = n, a = s), {
    width: l,
    height: a,
    $: r
  };
}
function Ja(e) {
  return st(e) ? e : e.contextElement;
}
function _t(e) {
  const t = Ja(e);
  if (!Ye(t))
    return dt(1);
  const l = t.getBoundingClientRect(), {
    width: a,
    height: o,
    $: n
  } = Ao(t);
  let s = (n ? Zt(l.width) : l.width) / a, r = (n ? Zt(l.height) : l.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!r || !Number.isFinite(r)) && (r = 1), {
    x: s,
    y: r
  };
}
const Us = /* @__PURE__ */ dt(0);
function Oo(e) {
  const t = Ie(e);
  return !Ka() || !t.visualViewport ? Us : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Xs(e, t, l) {
  return t === void 0 && (t = !1), !l || t && l !== Ie(e) ? !1 : t;
}
function yt(e, t, l, a) {
  t === void 0 && (t = !1), l === void 0 && (l = !1);
  const o = e.getBoundingClientRect(), n = Ja(e);
  let s = dt(1);
  t && (a ? st(a) && (s = _t(a)) : s = _t(e));
  const r = Xs(n, l, a) ? Oo(n) : dt(0);
  let i = (o.left + r.x) / s.x, d = (o.top + r.y) / s.y, y = o.width / s.x, b = o.height / s.y;
  if (n) {
    const c = Ie(n), h = a && st(a) ? Ie(a) : a;
    let S = c.frameElement;
    for (; S && a && h !== c; ) {
      const B = _t(S), F = S.getBoundingClientRect(), C = Me(S), V = F.left + (S.clientLeft + parseFloat(C.paddingLeft)) * B.x, T = F.top + (S.clientTop + parseFloat(C.paddingTop)) * B.y;
      i *= B.x, d *= B.y, y *= B.x, b *= B.y, i += V, d += T, S = Ie(S).frameElement;
    }
  }
  return Vt({
    width: y,
    height: b,
    x: i,
    y: d
  });
}
function Ks(e) {
  let {
    rect: t,
    offsetParent: l,
    strategy: a
  } = e;
  const o = Ye(l), n = rt(l);
  if (l === n)
    return t;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, r = dt(1);
  const i = dt(0);
  if ((o || !o && a !== "fixed") && ((ct(l) !== "body" || Rt(n)) && (s = fa(l)), Ye(l))) {
    const d = yt(l);
    r = _t(l), i.x = d.x + l.clientLeft, i.y = d.y + l.clientTop;
  }
  return {
    width: t.width * r.x,
    height: t.height * r.y,
    x: t.x * r.x - s.scrollLeft * r.x + i.x,
    y: t.y * r.y - s.scrollTop * r.y + i.y
  };
}
function Js(e) {
  return Array.from(e.getClientRects());
}
function Eo(e) {
  return yt(rt(e)).left + fa(e).scrollLeft;
}
function Ys(e) {
  const t = rt(e), l = fa(e), a = e.ownerDocument.body, o = Ke(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth), n = Ke(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);
  let s = -l.scrollLeft + Eo(e);
  const r = -l.scrollTop;
  return Me(a).direction === "rtl" && (s += Ke(t.clientWidth, a.clientWidth) - o), {
    width: o,
    height: n,
    x: s,
    y: r
  };
}
function Zs(e, t) {
  const l = Ie(e), a = rt(e), o = l.visualViewport;
  let n = a.clientWidth, s = a.clientHeight, r = 0, i = 0;
  if (o) {
    n = o.width, s = o.height;
    const d = Ka();
    (!d || d && t === "fixed") && (r = o.offsetLeft, i = o.offsetTop);
  }
  return {
    width: n,
    height: s,
    x: r,
    y: i
  };
}
function Qs(e, t) {
  const l = yt(e, !0, t === "fixed"), a = l.top + e.clientTop, o = l.left + e.clientLeft, n = Ye(e) ? _t(e) : dt(1), s = e.clientWidth * n.x, r = e.clientHeight * n.y, i = o * n.x, d = a * n.y;
  return {
    width: s,
    height: r,
    x: i,
    y: d
  };
}
function Bl(e, t, l) {
  let a;
  if (t === "viewport")
    a = Zs(e, l);
  else if (t === "document")
    a = Ys(rt(e));
  else if (st(t))
    a = Qs(t, l);
  else {
    const o = Oo(e);
    a = {
      ...t,
      x: t.x - o.x,
      y: t.y - o.y
    };
  }
  return Vt(a);
}
function Fo(e, t) {
  const l = At(e);
  return l === t || !st(l) || ca(l) ? !1 : Me(l).position === "fixed" || Fo(l, t);
}
function er(e, t) {
  const l = t.get(e);
  if (l)
    return l;
  let a = ta(e).filter((r) => st(r) && ct(r) !== "body"), o = null;
  const n = Me(e).position === "fixed";
  let s = n ? At(e) : e;
  for (; st(s) && !ca(s); ) {
    const r = Me(s), i = Xa(s);
    !i && r.position === "fixed" && (o = null), (n ? !i && !o : !i && r.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || Rt(s) && !i && Fo(e, s)) ? a = a.filter((y) => y !== s) : o = r, s = At(s);
  }
  return t.set(e, a), a;
}
function tr(e) {
  let {
    element: t,
    boundary: l,
    rootBoundary: a,
    strategy: o
  } = e;
  const s = [...l === "clippingAncestors" ? er(t, this._c) : [].concat(l), a], r = s[0], i = s.reduce((d, y) => {
    const b = Bl(t, y, o);
    return d.top = Ke(b.top, d.top), d.right = nt(b.right, d.right), d.bottom = nt(b.bottom, d.bottom), d.left = Ke(b.left, d.left), d;
  }, Bl(t, r, o));
  return {
    width: i.right - i.left,
    height: i.bottom - i.top,
    x: i.left,
    y: i.top
  };
}
function ar(e) {
  return Ao(e);
}
function lr(e, t, l) {
  const a = Ye(t), o = rt(t), n = l === "fixed", s = yt(e, !0, n, t);
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const i = dt(0);
  if (a || !a && !n)
    if ((ct(t) !== "body" || Rt(o)) && (r = fa(t)), a) {
      const d = yt(t, !0, n, t);
      i.x = d.x + t.clientLeft, i.y = d.y + t.clientTop;
    } else
      o && (i.x = Eo(o));
  return {
    x: s.left + r.scrollLeft - i.x,
    y: s.top + r.scrollTop - i.y,
    width: s.width,
    height: s.height
  };
}
function Sl(e, t) {
  return !Ye(e) || Me(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function Po(e, t) {
  const l = Ie(e);
  if (!Ye(e))
    return l;
  let a = Sl(e, t);
  for (; a && Gs(a) && Me(a).position === "static"; )
    a = Sl(a, t);
  return a && (ct(a) === "html" || ct(a) === "body" && Me(a).position === "static" && !Xa(a)) ? l : a || Ws(e) || l;
}
const or = async function(e) {
  let {
    reference: t,
    floating: l,
    strategy: a
  } = e;
  const o = this.getOffsetParent || Po, n = this.getDimensions;
  return {
    reference: lr(t, await o(l), a),
    floating: {
      x: 0,
      y: 0,
      ...await n(l)
    }
  };
};
function nr(e) {
  return Me(e).direction === "rtl";
}
const sr = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Ks,
  getDocumentElement: rt,
  getClippingRect: tr,
  getOffsetParent: Po,
  getElementRects: or,
  getClientRects: Js,
  getDimensions: ar,
  getScale: _t,
  isElement: st,
  isRTL: nr
};
function rr(e, t) {
  let l = null, a;
  const o = rt(e);
  function n() {
    clearTimeout(a), l && l.disconnect(), l = null;
  }
  function s(r, i) {
    r === void 0 && (r = !1), i === void 0 && (i = 1), n();
    const {
      left: d,
      top: y,
      width: b,
      height: c
    } = e.getBoundingClientRect();
    if (r || t(), !b || !c)
      return;
    const h = jt(y), S = jt(o.clientWidth - (d + b)), B = jt(o.clientHeight - (y + c)), F = jt(d), V = {
      rootMargin: -h + "px " + -S + "px " + -B + "px " + -F + "px",
      threshold: Ke(0, nt(1, i)) || 1
    };
    let T = !0;
    function $(m) {
      const k = m[0].intersectionRatio;
      if (k !== i) {
        if (!T)
          return s();
        k ? s(!1, k) : a = setTimeout(() => {
          s(!1, 1e-7);
        }, 100);
      }
      T = !1;
    }
    try {
      l = new IntersectionObserver($, {
        ...V,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      l = new IntersectionObserver($, V);
    }
    l.observe(e);
  }
  return s(!0), n;
}
function No(e, t, l, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: n = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: r = typeof IntersectionObserver == "function",
    animationFrame: i = !1
  } = a, d = Ja(e), y = o || n ? [...d ? ta(d) : [], ...ta(t)] : [];
  y.forEach((C) => {
    o && C.addEventListener("scroll", l, {
      passive: !0
    }), n && C.addEventListener("resize", l);
  });
  const b = d && r ? rr(d, l) : null;
  let c = -1, h = null;
  s && (h = new ResizeObserver((C) => {
    let [V] = C;
    V && V.target === d && h && (h.unobserve(t), cancelAnimationFrame(c), c = requestAnimationFrame(() => {
      h && h.observe(t);
    })), l();
  }), d && !i && h.observe(d), h.observe(t));
  let S, B = i ? yt(e) : null;
  i && F();
  function F() {
    const C = yt(e);
    B && (C.x !== B.x || C.y !== B.y || C.width !== B.width || C.height !== B.height) && l(), B = C, S = requestAnimationFrame(F);
  }
  return l(), () => {
    y.forEach((C) => {
      o && C.removeEventListener("scroll", l), n && C.removeEventListener("resize", l);
    }), b && b(), h && h.disconnect(), h = null, i && cancelAnimationFrame(S);
  };
}
const ir = (e, t, l) => {
  const a = /* @__PURE__ */ new Map(), o = {
    platform: sr,
    ...l
  }, n = {
    ...o.platform,
    _c: a
  };
  return Hs(e, t, {
    ...o,
    platform: n
  });
};
function $a(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
function ur(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const l = $a(g(e.element));
      return l == null ? {} : zs({
        element: l,
        padding: e.padding
      }).fn(t);
    }
  };
}
function Lo(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function wl(e, t) {
  const l = Lo(e);
  return Math.round(t * l) / l;
}
function Io(e, t, l) {
  l === void 0 && (l = {});
  const a = l.whileElementsMounted, o = w(() => {
    var f;
    return (f = g(l.open)) != null ? f : !0;
  }), n = w(() => g(l.middleware)), s = w(() => {
    var f;
    return (f = g(l.placement)) != null ? f : "bottom";
  }), r = w(() => {
    var f;
    return (f = g(l.strategy)) != null ? f : "absolute";
  }), i = w(() => {
    var f;
    return (f = g(l.transform)) != null ? f : !0;
  }), d = w(() => $a(e.value)), y = w(() => $a(t.value)), b = R(0), c = R(0), h = R(r.value), S = R(s.value), B = Na({}), F = R(!1), C = w(() => {
    const f = {
      position: h.value,
      left: "0",
      top: "0"
    };
    if (!y.value)
      return f;
    const _ = wl(y.value, b.value), L = wl(y.value, c.value);
    return i.value ? {
      ...f,
      transform: "translate(" + _ + "px, " + L + "px)",
      ...Lo(y.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: h.value,
      left: _ + "px",
      top: L + "px"
    };
  });
  let V;
  function T() {
    d.value == null || y.value == null || ir(d.value, y.value, {
      middleware: n.value,
      placement: s.value,
      strategy: r.value
    }).then((f) => {
      b.value = f.x, c.value = f.y, h.value = f.strategy, S.value = f.placement, B.value = f.middlewareData, F.value = !0;
    });
  }
  function $() {
    typeof V == "function" && (V(), V = void 0);
  }
  function m() {
    if ($(), a === void 0) {
      T();
      return;
    }
    if (d.value != null && y.value != null) {
      V = a(d.value, y.value, T);
      return;
    }
  }
  function k() {
    o.value || (F.value = !1);
  }
  return re([n, s, r], T, {
    flush: "sync"
  }), re([d, y], m, {
    flush: "sync"
  }), re(o, k, {
    flush: "sync"
  }), Kl() && Jl($), {
    x: wt(b),
    y: wt(c),
    strategy: wt(h),
    placement: wt(S),
    middlewareData: wt(B),
    isPositioned: wt(F),
    floatingStyles: C,
    update: T
  };
}
const dr = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), cr = /^aria-[\w-]*$/i, fr = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, vr = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, pr = (e, t) => {
  const l = e.nodeName.toLowerCase();
  return t.includes(l) ? dr.has(l) ? !!(fr.test(e.nodeValue || "") || vr.test(e.nodeValue || "")) : !0 : t.filter((a) => a instanceof RegExp).some((a) => a.test(l));
}, kt = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", cr],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, $t = (e, t, l) => {
  if (!e.length)
    return e;
  if (l && typeof l == "function")
    return l(e);
  const o = new window.DOMParser().parseFromString(e, "text/html"), n = o.body.querySelectorAll("*");
  for (const s of n) {
    const r = s.nodeName.toLowerCase();
    if (!Object.keys(t).includes(r)) {
      s.remove();
      continue;
    }
    const i = s.attributes, d = [...t["*"] || [], ...t[r] || []];
    for (const y of i)
      pr(y, d) || s.removeAttribute(y.nodeName);
  }
  return o.body.innerHTML;
};
function Ho(e, t) {
  var l;
  const a = Na();
  return Ot(() => {
    a.value = e();
  }, {
    ...t,
    flush: (l = t == null ? void 0 : t.flush) != null ? l : "sync"
  }), Ee(a);
}
function bt(e) {
  return Kl() ? (Jl(e), !0) : !1;
}
function zo(e) {
  let t = !1, l;
  const a = Yl(!0);
  return (...o) => (t || (l = a.run(() => e(...o)), t = !0), l);
}
function mr(e) {
  let t = 0, l, a;
  const o = () => {
    t -= 1, a && t <= 0 && (a.stop(), l = void 0, a = void 0);
  };
  return (...n) => (t += 1, l || (a = Yl(!0), l = a.run(() => e(...n))), bt(o), l);
}
function Re(e) {
  return typeof e == "function" ? e() : g(e);
}
const aa = typeof window < "u" && typeof document < "u", gr = (e) => typeof e < "u", yr = Object.prototype.toString, br = (e) => yr.call(e) === "[object Object]", ft = () => {
}, _a = /* @__PURE__ */ hr();
function hr() {
  var e;
  return aa && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);
}
function xo(e, t) {
  function l(...a) {
    return new Promise((o, n) => {
      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(o).catch(n);
    });
  }
  return l;
}
const Ro = (e) => e();
function Br(e, t = {}) {
  let l, a, o = ft;
  const n = (r) => {
    clearTimeout(r), o(), o = ft;
  };
  return (r) => {
    const i = Re(e), d = Re(t.maxWait);
    return l && n(l), i <= 0 || d !== void 0 && d <= 0 ? (a && (n(a), a = null), Promise.resolve(r())) : new Promise((y, b) => {
      o = t.rejectOnCancel ? b : y, d && !a && (a = setTimeout(() => {
        l && n(l), a = null, y(r());
      }, d)), l = setTimeout(() => {
        a && n(a), a = null, y(r());
      }, i);
    });
  };
}
function Sr(e = Ro) {
  const t = R(!0);
  function l() {
    t.value = !1;
  }
  function a() {
    t.value = !0;
  }
  const o = (...n) => {
    t.value && e(...n);
  };
  return { isActive: Ee(t), pause: l, resume: a, eventFilter: o };
}
function Mo(...e) {
  if (e.length !== 1)
    return N(...e);
  const t = e[0];
  return typeof t == "function" ? Ee(jn(() => ({ get: t, set: ft }))) : R(t);
}
function wr(e, t = 200, l = {}) {
  return xo(
    Br(t, l),
    e
  );
}
function Cr(e, t, l = {}) {
  const {
    eventFilter: a = Ro,
    ...o
  } = l;
  return re(
    e,
    xo(
      a,
      t
    ),
    o
  );
}
function kr(e, t, l = {}) {
  const {
    eventFilter: a,
    ...o
  } = l, { eventFilter: n, pause: s, resume: r, isActive: i } = Sr(a);
  return { stop: Cr(
    e,
    t,
    {
      ...o,
      eventFilter: n
    }
  ), pause: s, resume: r, isActive: i };
}
function $r(e, t = !0) {
  Et() ? Ze(e) : t ? e() : _e(e);
}
function Do(e, t = 1e3, l = {}) {
  const {
    immediate: a = !0,
    immediateCallback: o = !1
  } = l;
  let n = null;
  const s = R(!1);
  function r() {
    n && (clearInterval(n), n = null);
  }
  function i() {
    s.value = !1, r();
  }
  function d() {
    const y = Re(t);
    y <= 0 || (s.value = !0, o && e(), r(), n = setInterval(e, y));
  }
  if (a && aa && d(), La(t) || typeof t == "function") {
    const y = re(t, () => {
      s.value && aa && d();
    });
    bt(y);
  }
  return bt(i), {
    isActive: s,
    pause: i,
    resume: d
  };
}
function Be(e, t = {}) {
  const {
    method: l = "parseFloat",
    radix: a,
    nanToZero: o
  } = t;
  return w(() => {
    let n = Re(e);
    return typeof n == "string" && (n = Number[l](n, a)), o && Number.isNaN(n) && (n = 0), n;
  });
}
function lt(e) {
  var t;
  const l = Re(e);
  return (t = l == null ? void 0 : l.$el) != null ? t : l;
}
const We = aa ? window : void 0;
function we(...e) {
  let t, l, a, o;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([l, a, o] = e, t = We) : [t, l, a, o] = e, !t)
    return ft;
  Array.isArray(l) || (l = [l]), Array.isArray(a) || (a = [a]);
  const n = [], s = () => {
    n.forEach((y) => y()), n.length = 0;
  }, r = (y, b, c, h) => (y.addEventListener(b, c, h), () => y.removeEventListener(b, c, h)), i = re(
    () => [lt(t), Re(o)],
    ([y, b]) => {
      if (s(), !y)
        return;
      const c = br(b) ? { ...b } : b;
      n.push(
        ...l.flatMap((h) => a.map((S) => r(y, h, S, c)))
      );
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    i(), s();
  };
  return bt(d), d;
}
let Cl = !1;
function jo(e, t, l = {}) {
  const { window: a = We, ignore: o = [], capture: n = !0, detectIframe: s = !1 } = l;
  if (!a)
    return;
  _a && !Cl && (Cl = !0, Array.from(a.document.body.children).forEach((c) => c.addEventListener("click", ft)), a.document.documentElement.addEventListener("click", ft));
  let r = !0;
  const i = (c) => o.some((h) => {
    if (typeof h == "string")
      return Array.from(a.document.querySelectorAll(h)).some((S) => S === c.target || c.composedPath().includes(S));
    {
      const S = lt(h);
      return S && (c.target === S || c.composedPath().includes(S));
    }
  }), y = [
    we(a, "click", (c) => {
      const h = lt(e);
      if (!(!h || h === c.target || c.composedPath().includes(h))) {
        if (c.detail === 0 && (r = !i(c)), !r) {
          r = !0;
          return;
        }
        t(c);
      }
    }, { passive: !0, capture: n }),
    we(a, "pointerdown", (c) => {
      const h = lt(e);
      h && (r = !c.composedPath().includes(h) && !i(c));
    }, { passive: !0 }),
    s && we(a, "blur", (c) => {
      setTimeout(() => {
        var h;
        const S = lt(e);
        ((h = a.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(S != null && S.contains(a.document.activeElement)) && t(c);
      }, 0);
    })
  ].filter(Boolean);
  return () => y.forEach((c) => c());
}
function _r(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function je(...e) {
  let t, l, a = {};
  e.length === 3 ? (t = e[0], l = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, l = e[0], a = e[1]) : (t = e[0], l = e[1]) : (t = !0, l = e[0]);
  const {
    target: o = We,
    eventName: n = "keydown",
    passive: s = !1,
    dedupe: r = !1
  } = a, i = _r(t);
  return we(o, n, (y) => {
    y.repeat && Re(r) || i(y) && l(y);
  }, s);
}
function Tr() {
  const e = R(!1);
  return Et() && Ze(() => {
    e.value = !0;
  }), e;
}
function Vr(e) {
  const t = Tr();
  return w(() => (t.value, !!e()));
}
function Ar(e, t = {}) {
  const { window: l = We } = t, a = Vr(() => l && "matchMedia" in l && typeof l.matchMedia == "function");
  let o;
  const n = R(!1), s = (d) => {
    n.value = d.matches;
  }, r = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", s) : o.removeListener(s));
  }, i = Ot(() => {
    a.value && (r(), o = l.matchMedia(Re(e)), "addEventListener" in o ? o.addEventListener("change", s) : o.addListener(s), n.value = o.matches);
  });
  return bt(() => {
    i(), r(), o = void 0;
  }), n;
}
function Or(e) {
  return JSON.parse(JSON.stringify(e));
}
const qt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Gt = "__vueuse_ssr_handlers__", Er = /* @__PURE__ */ Fr();
function Fr() {
  return Gt in qt || (qt[Gt] = qt[Gt] || {}), qt[Gt];
}
function Ya(e, t) {
  return Er[e] || t;
}
function Pr(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
const Nr = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, kl = "vueuse-storage";
function Lr(e, t, l, a = {}) {
  var o;
  const {
    flush: n = "pre",
    deep: s = !0,
    listenToStorageChanges: r = !0,
    writeDefaults: i = !0,
    mergeDefaults: d = !1,
    shallow: y,
    window: b = We,
    eventFilter: c,
    onError: h = (_) => {
      console.error(_);
    }
  } = a, S = (y ? Na : R)(t);
  if (!l)
    try {
      l = Ya("getDefaultStorage", () => {
        var _;
        return (_ = We) == null ? void 0 : _.localStorage;
      })();
    } catch (_) {
      h(_);
    }
  if (!l)
    return S;
  const B = Re(t), F = Pr(B), C = (o = a.serializer) != null ? o : Nr[F], { pause: V, resume: T } = kr(
    S,
    () => $(S.value),
    { flush: n, deep: s, eventFilter: c }
  );
  return b && r && (we(b, "storage", f), we(b, kl, k)), f(), S;
  function $(_) {
    try {
      if (_ == null)
        l.removeItem(e);
      else {
        const L = C.write(_), v = l.getItem(e);
        v !== L && (l.setItem(e, L), b && b.dispatchEvent(new CustomEvent(kl, {
          detail: {
            key: e,
            oldValue: v,
            newValue: L,
            storageArea: l
          }
        })));
      }
    } catch (L) {
      h(L);
    }
  }
  function m(_) {
    const L = _ ? _.newValue : l.getItem(e);
    if (L == null)
      return i && B !== null && l.setItem(e, C.write(B)), B;
    if (!_ && d) {
      const v = C.read(L);
      return typeof d == "function" ? d(v, B) : F === "object" && !Array.isArray(v) ? { ...B, ...v } : v;
    } else
      return typeof L != "string" ? L : C.read(L);
  }
  function k(_) {
    f(_.detail);
  }
  function f(_) {
    if (!(_ && _.storageArea !== l)) {
      if (_ && _.key == null) {
        S.value = B;
        return;
      }
      if (!(_ && _.key !== e)) {
        V();
        try {
          (_ == null ? void 0 : _.newValue) !== C.write(S.value) && (S.value = m(_));
        } catch (L) {
          h(L);
        } finally {
          _ ? _e(T) : T();
        }
      }
    }
  }
}
function Ir(e) {
  return Ar("(prefers-color-scheme: dark)", e);
}
function Hr(e = {}) {
  const {
    selector: t = "html",
    attribute: l = "class",
    initialValue: a = "auto",
    window: o = We,
    storage: n,
    storageKey: s = "vueuse-color-scheme",
    listenToStorageChanges: r = !0,
    storageRef: i,
    emitAuto: d,
    disableTransition: y = !0
  } = e, b = {
    auto: "",
    light: "light",
    dark: "dark",
    ...e.modes || {}
  }, c = Ir({ window: o }), h = w(() => c.value ? "dark" : "light"), S = i || (s == null ? Mo(a) : Lr(s, a, n, { window: o, listenToStorageChanges: r })), B = w(
    () => S.value === "auto" ? h.value : S.value
  ), F = Ya(
    "updateHTMLAttrs",
    ($, m, k) => {
      const f = typeof $ == "string" ? o == null ? void 0 : o.document.querySelector($) : lt($);
      if (!f)
        return;
      let _;
      if (y) {
        _ = o.document.createElement("style");
        const L = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
        _.appendChild(document.createTextNode(L)), o.document.head.appendChild(_);
      }
      if (m === "class") {
        const L = k.split(/\s/g);
        Object.values(b).flatMap((v) => (v || "").split(/\s/g)).filter(Boolean).forEach((v) => {
          L.includes(v) ? f.classList.add(v) : f.classList.remove(v);
        });
      } else
        f.setAttribute(m, k);
      y && (o.getComputedStyle(_).opacity, document.head.removeChild(_));
    }
  );
  function C($) {
    var m;
    F(t, l, (m = b[$]) != null ? m : $);
  }
  function V($) {
    e.onChanged ? e.onChanged($, C) : C($);
  }
  re(B, V, { flush: "post", immediate: !0 }), $r(() => V(B.value));
  const T = w({
    get() {
      return d ? S.value : B.value;
    },
    set($) {
      S.value = $;
    }
  });
  try {
    return Object.assign(T, { store: S, system: h, state: B });
  } catch {
    return T;
  }
}
function Za(e, t = {}) {
  const {
    delayEnter: l = 0,
    delayLeave: a = 0,
    window: o = We
  } = t, n = R(!1);
  let s;
  const r = (i) => {
    const d = i ? l : a;
    s && (clearTimeout(s), s = void 0), d ? s = setTimeout(() => n.value = i, d) : n.value = i;
  };
  return o && (we(e, "mouseenter", () => r(!0), { passive: !0 }), we(e, "mouseleave", () => r(!1), { passive: !0 })), n;
}
function Ne(e, t = {}) {
  const { initialValue: l = !1, focusVisible: a = !1 } = t, o = R(!1), n = w(() => lt(e));
  we(n, "focus", (r) => {
    var i, d;
    (!a || (d = (i = r.target).matches) != null && d.call(i, ":focus-visible")) && (o.value = !0);
  }), we(n, "blur", () => o.value = !1);
  const s = w({
    get: () => o.value,
    set(r) {
      var i, d;
      !r && o.value ? (i = n.value) == null || i.blur() : r && !o.value && ((d = n.value) == null || d.focus());
    }
  });
  return re(
    n,
    () => {
      s.value = l;
    },
    { immediate: !0, flush: "post" }
  ), { focused: s };
}
function ba(e) {
  return typeof Window < "u" && e instanceof Window ? e.document.documentElement : typeof Document < "u" && e instanceof Document ? e.documentElement : e;
}
const zr = {
  page: (e) => [e.pageX, e.pageY],
  client: (e) => [e.clientX, e.clientY],
  screen: (e) => [e.screenX, e.screenY],
  movement: (e) => e instanceof Touch ? null : [e.movementX, e.movementY]
};
function xr(e = {}) {
  const {
    type: t = "page",
    touch: l = !0,
    resetOnTouchEnds: a = !1,
    initialValue: o = { x: 0, y: 0 },
    window: n = We,
    target: s = n,
    scroll: r = !0,
    eventFilter: i
  } = e;
  let d = null;
  const y = R(o.x), b = R(o.y), c = R(null), h = typeof t == "function" ? t : zr[t], S = (m) => {
    const k = h(m);
    d = m, k && ([y.value, b.value] = k, c.value = "mouse");
  }, B = (m) => {
    if (m.touches.length > 0) {
      const k = h(m.touches[0]);
      k && ([y.value, b.value] = k, c.value = "touch");
    }
  }, F = () => {
    if (!d || !n)
      return;
    const m = h(d);
    d instanceof MouseEvent && m && (y.value = m[0] + n.scrollX, b.value = m[1] + n.scrollY);
  }, C = () => {
    y.value = o.x, b.value = o.y;
  }, V = i ? (m) => i(() => S(m), {}) : (m) => S(m), T = i ? (m) => i(() => B(m), {}) : (m) => B(m), $ = i ? () => i(() => F(), {}) : () => F();
  if (s) {
    const m = { passive: !0 };
    we(s, ["mousemove", "dragover"], V, m), l && t !== "movement" && (we(s, ["touchstart", "touchmove"], T, m), a && we(s, "touchend", C, m)), r && t === "page" && we(n, "scroll", $, { passive: !0 });
  }
  return {
    x: y,
    y: b,
    sourceType: c
  };
}
function $l(e, t = {}) {
  const {
    handleOutside: l = !0,
    window: a = We
  } = t, { x: o, y: n, sourceType: s } = xr(t), r = R(e ?? (a == null ? void 0 : a.document.body)), i = R(0), d = R(0), y = R(0), b = R(0), c = R(0), h = R(0), S = R(!0);
  let B = () => {
  };
  return a && (B = re(
    [r, o, n],
    () => {
      const F = lt(r);
      if (!F)
        return;
      const {
        left: C,
        top: V,
        width: T,
        height: $
      } = F.getBoundingClientRect();
      y.value = C + a.pageXOffset, b.value = V + a.pageYOffset, c.value = $, h.value = T;
      const m = o.value - y.value, k = n.value - b.value;
      S.value = T === 0 || $ === 0 || m < 0 || k < 0 || m > T || k > $, (l || !S.value) && (i.value = m, d.value = k);
    },
    { immediate: !0 }
  ), we(document, "mouseleave", () => {
    S.value = !0;
  })), {
    x: o,
    y: n,
    sourceType: s,
    elementX: i,
    elementY: d,
    elementPositionX: y,
    elementPositionY: b,
    elementHeight: c,
    elementWidth: h,
    isOutside: S,
    stop: B
  };
}
function qo(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return !0;
  {
    const l = e.parentNode;
    return !l || l.tagName === "BODY" ? !1 : qo(l);
  }
}
function Rr(e) {
  const t = e || window.event, l = t.target;
  return qo(l) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1);
}
function Mr(e, t = !1) {
  const l = R(t);
  let a = null, o;
  re(Mo(e), (r) => {
    const i = ba(Re(r));
    if (i) {
      const d = i;
      o = d.style.overflow, l.value && (d.style.overflow = "hidden");
    }
  }, {
    immediate: !0
  });
  const n = () => {
    const r = ba(Re(e));
    !r || l.value || (_a && (a = we(
      r,
      "touchmove",
      (i) => {
        Rr(i);
      },
      { passive: !1 }
    )), r.style.overflow = "hidden", l.value = !0);
  }, s = () => {
    const r = ba(Re(e));
    !r || !l.value || (_a && (a == null || a()), r.style.overflow = o, l.value = !1);
  };
  return bt(s), w({
    get() {
      return l.value;
    },
    set(r) {
      r ? n() : s();
    }
  });
}
function Dr(e, t = {}) {
  const {
    threshold: l = 50,
    onSwipe: a,
    onSwipeEnd: o,
    onSwipeStart: n,
    passive: s = !0,
    window: r = We
  } = t, i = It({ x: 0, y: 0 }), d = It({ x: 0, y: 0 }), y = w(() => i.x - d.x), b = w(() => i.y - d.y), { max: c, abs: h } = Math, S = w(() => c(h(y.value), h(b.value)) >= l), B = R(!1), F = w(() => S.value ? h(y.value) > h(b.value) ? y.value > 0 ? "left" : "right" : b.value > 0 ? "up" : "down" : "none"), C = (L) => [L.touches[0].clientX, L.touches[0].clientY], V = (L, v) => {
    i.x = L, i.y = v;
  }, T = (L, v) => {
    d.x = L, d.y = v;
  };
  let $;
  const m = jr(r == null ? void 0 : r.document);
  s ? $ = m ? { passive: !0 } : { capture: !1 } : $ = m ? { passive: !1, capture: !0 } : { capture: !0 };
  const k = (L) => {
    B.value && (o == null || o(L, F.value)), B.value = !1;
  }, f = [
    we(e, "touchstart", (L) => {
      if (L.touches.length !== 1)
        return;
      $.capture && !$.passive && L.preventDefault();
      const [v, I] = C(L);
      V(v, I), T(v, I), n == null || n(L);
    }, $),
    we(e, "touchmove", (L) => {
      if (L.touches.length !== 1)
        return;
      const [v, I] = C(L);
      T(v, I), !B.value && S.value && (B.value = !0), B.value && (a == null || a(L));
    }, $),
    we(e, ["touchend", "touchcancel"], k, $)
  ];
  return {
    isPassiveEventSupported: m,
    isSwiping: B,
    direction: F,
    coordsStart: i,
    coordsEnd: d,
    lengthX: y,
    lengthY: b,
    stop: () => f.forEach((L) => L())
  };
}
function jr(e) {
  if (!e)
    return !1;
  let t = !1;
  const l = {
    get passive() {
      return t = !0, !1;
    }
  };
  return e.addEventListener("x", ft, l), e.removeEventListener("x", ft), t;
}
function Se(e, t, l, a = {}) {
  var o, n, s;
  const {
    clone: r = !1,
    passive: i = !1,
    eventName: d,
    deep: y = !1,
    defaultValue: b,
    shouldEmit: c
  } = a, h = Et(), S = l || (h == null ? void 0 : h.emit) || ((o = h == null ? void 0 : h.$emit) == null ? void 0 : o.bind(h)) || ((s = (n = h == null ? void 0 : h.proxy) == null ? void 0 : n.$emit) == null ? void 0 : s.bind(h == null ? void 0 : h.proxy));
  let B = d;
  t || (t = "modelValue"), B = B || `update:${t.toString()}`;
  const F = (T) => r ? typeof r == "function" ? r(T) : Or(T) : T, C = () => gr(e[t]) ? F(e[t]) : b, V = (T) => {
    c ? c(T) && S(B, T) : S(B, T);
  };
  if (i) {
    const T = C(), $ = R(T);
    let m = !1;
    return re(
      () => e[t],
      (k) => {
        m || (m = !0, $.value = F(k), _e(() => m = !1));
      }
    ), re(
      $,
      (k) => {
        !m && (k !== e[t] || y) && V(k);
      },
      { deep: y }
    ), $;
  } else
    return w({
      get() {
        return C();
      },
      set(T) {
        V(T);
      }
    });
}
const va = x({
  name: "ComponentOrEmpty",
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, { slots: t, attrs: l }) {
    return () => {
      var a, o, n;
      return e.skip ? (a = t.default) == null ? void 0 : a.call(t) : e.tag === "Teleport" ? ge(sa, { to: e.to }, [(o = t.default) == null ? void 0 : o.call(t)]) : ge(e.tag, { ...l }, [(n = t.default) == null ? void 0 : n.call(t)]);
    };
  }
}), Mt = (e) => Ho(() => {
  const t = Qe(e);
  return t ? `justify-content-${t}` : "";
}), ht = (e, t) => {
  const l = N(t), a = N(e), o = w(() => As(a.value)), n = w(
    () => o.value ? Da(
      a.value,
      l.value ?? [
        "active",
        "activeClass",
        "append",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover"
      ]
    ) : {}
  );
  return { computedLink: o, computedLinkProps: n };
}, qe = (e) => w(() => {
  const t = Qe(e);
  return {
    [`text-bg-${t.variant}`]: t.variant !== null,
    [`text-${t.textVariant}`]: t.textVariant !== null && t.variant === null,
    [`bg-${t.bgVariant}`]: t.bgVariant !== null && t.variant === null
  };
});
function u(e) {
  return Ho(() => {
    const t = Qe(e);
    return t == null ? t : ia(t);
  });
}
const Go = zo(() => {
  const e = It([]);
  return { items: e, reset: () => {
    e.splice(0, e.length);
  } };
}), qr = (e = {}) => {
  const t = e.persist ?? !1, l = "data-bs-theme", a = "body";
  return Hr({
    attribute: l,
    selector: a,
    storageKey: t === !0 ? `bv-color-${e.attribute ?? l}-${e.selector ?? a}` : null,
    ...e
  });
}, Wo = (e, t = R(1e3), l = {}) => {
  const a = Ee(N(e)), o = Ee(N(t)), n = R(!1), s = R(0), r = N(() => Math.ceil(a.value / o.value)), i = N(
    () => b.value || n.value ? Math.round(a.value - s.value * o.value) : 0
  ), { pause: d, resume: y, isActive: b } = Do(
    () => {
      s.value = s.value + 1;
    },
    t,
    l
  ), c = () => {
    n.value = !1, s.value = 0, y();
  }, h = () => {
    n.value = !1, s.value = r.value;
  };
  Ot(() => {
    s.value > r.value && (s.value = r.value), s.value === r.value && d();
  }), re([o, a], () => {
    h(), c();
  });
  const S = () => {
    b.value !== !1 && (n.value = !0, d());
  }, B = () => {
    s.value !== r.value && (n.value = !1, y());
  };
  return {
    isActive: Ee(b),
    isPaused: Ee(n),
    restart: c,
    stop: h,
    pause: S,
    resume: B,
    value: i
  };
}, Bt = (e) => w(() => {
  const t = Qe(e);
  return t === !0 ? "is-valid" : t === !1 ? "is-invalid" : null;
}), Uo = (e) => w(() => {
  const t = Qe(e);
  return {
    "form-check": t.plain === !1 && t.button === !1,
    "form-check-inline": t.inline === !0,
    "form-switch": t.switch === !0,
    [`form-control-${t.size}`]: t.size !== void 0 && t.size !== "md" && t.button === !1
  };
}), Xo = (e) => {
  const t = N(e), l = Bt(N(() => t.value.state ?? null));
  return w(() => [
    l.value,
    {
      "form-check-input": t.value.plain === !1 && t.value.button === !1,
      "btn-check": t.value.button === !0
    }
  ]);
}, Ko = (e) => w(() => {
  const t = Qe(e);
  return {
    "form-check-label": t.plain === !1 && t.button === !1,
    btn: t.button === !0,
    [`btn-${t.buttonVariant}`]: t.button === !0 && t.buttonVariant !== void 0 && t.buttonVariant !== null,
    [`btn-${t.size}`]: t.button && t.size && t.size !== "md"
  };
}), Jo = (e) => w(() => {
  const t = Qe(e);
  return {
    "aria-invalid": da(t.ariaInvalid, t.state),
    "aria-required": t.required === !0 ? !0 : void 0
  };
}), Yo = (e) => w(() => {
  const t = Qe(e);
  return {
    "was-validated": t.validated === !0,
    "btn-group": t.buttons === !0 && t.stacked === !1,
    "btn-group-vertical": t.stacked === !0 && t.buttons === !0,
    [`btn-group-${t.size}`]: t.size !== void 0
  };
}), Zo = (e, t) => {
  const l = R(null);
  let a = null, o = !0;
  const n = Se(e, "modelValue", t), s = ke(() => e.id, "input"), r = u(() => e.autofocus), i = u(() => e.disabled), d = u(() => e.lazy), y = u(() => e.lazyFormatter), b = u(() => e.number), c = u(() => e.state), h = u(() => e.trim), S = Be(N(() => e.debounce ?? 0)), B = Be(N(() => e.debounceMaxWait ?? NaN)), F = N(
    () => d.value === !0 ? 0 : S.value
  ), C = N(
    () => d.value === !0 ? NaN : B.value
  ), V = wr(
    (O) => {
      n.value = O;
    },
    F,
    { maxWait: C }
  ), T = (O, q = !1) => {
    d.value === !0 && q === !1 || V(O);
  }, { focused: $ } = Ne(l, {
    initialValue: r.value
  }), m = (O, q, Q = !1) => (O = String(O), typeof e.formatter == "function" && (!y.value || Q) ? (o = !1, e.formatter(O, q)) : O), k = (O) => h.value ? O.trim() : b.value ? Number.parseFloat(O) : O;
  Ze(() => {
    l.value && (l.value.value = n.value);
  }), qn(() => {
    _e(() => {
      r.value && ($.value = !0);
    });
  });
  const f = w(
    () => da(e.ariaInvalid, c.value)
  ), _ = (O) => {
    const { value: q } = O.target, Q = m(q, O);
    if (Q === !1 || O.defaultPrevented) {
      O.preventDefault();
      return;
    }
    const X = k(Q);
    a = q, T(X), t("input", Q);
  }, L = (O) => {
    const { value: q } = O.target, Q = m(q, O);
    if (Q === !1 || O.defaultPrevented) {
      O.preventDefault();
      return;
    }
    const X = k(Q);
    n.value !== X && (a = q, T(Q, !0)), t("change", Q);
  }, v = (O) => {
    if (t("blur", O), !d.value && !y.value)
      return;
    const { value: q } = O.target, Q = m(q, O, !0), X = k(Q);
    n.value !== X && (a = q, T(Q, !0));
  }, I = () => {
    i.value || ($.value = !0);
  }, H = () => {
    i.value || ($.value = !1);
  };
  return re(n, (O) => {
    l.value && (l.value.value = a && o ? a : O, a = null, o = !0);
  }), {
    input: l,
    computedId: s,
    computedAriaInvalid: f,
    onInput: _,
    onChange: L,
    onBlur: v,
    focus: I,
    blur: H
  };
}, Ct = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const l = t.split(".");
  return Ct(e[l[0]], l.splice(1).join("."));
}, ha = (e, t = null, l, a) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const o = Ct(e, a.valueField), n = Ct(e, a.textField), s = Ct(e, a.htmlField), r = Ct(e, a.disabledField), i = e[a.optionsField] || null;
    return i !== null ? {
      label: String(Ct(e, a.labelField) || n),
      options: Qa(i, l, a)
    } : {
      value: typeof o > "u" ? t || n : o,
      text: String(typeof n > "u" ? t : n),
      html: s,
      disabled: !!r
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: !1
  };
}, Qa = (e, t, l) => Array.isArray(e) ? e.map((a) => ha(a, null, t, l)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((a) => {
  const o = e[a];
  switch (typeof o) {
    case "object":
      return ha(o.text, String(o.value), t, l);
    default:
      return ha(o, String(a), t, l);
  }
})) : [], ke = (e, t) => w(() => Qe(e) || mt(t)), Ba = "modal-open", el = mr(() => {
  const e = R([]), t = R([]), l = N(() => t.value.length), a = N(() => t.value[t.value.length - 1]), o = (d) => t.value.push(d), n = () => t.value.pop(), s = (d) => {
    t.value = t.value.filter((y) => y.uid !== d.uid);
  }, r = (d) => e.value.find((y) => {
    var b;
    return ((b = y.exposed) == null ? void 0 : b.id) === d;
  }) || null, i = Ya("updateHTMLAttrs", (d, y, b) => {
    const c = typeof d == "string" ? window == null ? void 0 : window.document.querySelector(d) : lt(d);
    c && (y === "class" ? c.classList.toggle(Ba, b === Ba) : c.setAttribute(y, b));
  });
  return bt(() => {
    i("body", "class", "");
  }), re(l, (d) => {
    i("body", "class", d > 0 ? Ba : "");
  }), { registry: e, stack: t, last: a, count: l, push: o, pop: n, remove: s, find: r };
}), Gr = (e, t) => {
  const { registry: l, push: a, remove: o, stack: n } = el(), s = Et();
  if (!s || s.type.__name !== "BModal")
    throw new Error("useModalManager must only use in BModal component");
  return l.value.push(s), re(
    e,
    (r, i) => {
      r ? a(s) : i && !r && o(s);
    },
    { immediate: !0 }
  ), {
    activePosition: w(() => n.value.findIndex((r) => {
      var i;
      return ((i = r.exposed) == null ? void 0 : i.id) === Qe(t);
    })),
    activeModalCount: N(() => n.value.length)
  };
}, Wr = (e = void 0) => {
  const { find: t } = el(), l = Et(), a = w(() => e ? t(e) : l ? Qo(l) : null), o = N(() => {
    var n;
    return (n = a.value) == null ? void 0 : n.proxy;
  });
  return {
    show() {
      var n, s;
      (s = (n = a.value) == null ? void 0 : n.exposed) == null || s.show();
    },
    hide(n = "") {
      var s, r;
      (r = (s = a.value) == null ? void 0 : s.exposed) == null || r.hide(n);
    },
    modal: o
  };
}, Qo = (e) => e.parent ? e.parent.type.__name === "BModal" ? e.parent : Qo(e.parent) : null, Ur = () => {
  const { last: e, stack: t } = el();
  return {
    hide: (o = "") => {
      var n;
      e.value && ((n = e.value.exposed) == null || n.hide(o));
    },
    hideAll: (o = "") => {
      var s;
      const n = t.value.reverse();
      for (const r of n)
        (s = r.exposed) == null || s.hide(o);
    }
    // Todo: Supports listening events globally in the future
  };
}, en = (e, t) => {
  const l = Ee(N(e)), a = Ee(N(t)), o = N(() => !a.value);
  Ze(() => {
    const n = Mr(
      document.body,
      l.value && o.value
    );
    re([l, o], ([s, r]) => {
      n.value = s && r;
    });
  });
}, Xr = (e, t, l, a, o) => {
  if (e === void 0 || t === void 0 || l === void 0 || a === void 0)
    return t ?? [];
  const n = l;
  return t.sort((s, r) => {
    if (o !== void 0)
      return o(s, r, l, a);
    const i = (b) => typeof b == "object" ? JSON.stringify(b) : b;
    return i(s[n]) > i(r[n]) ? a ? -1 : 1 : i(r[n]) > i(s[n]) ? a ? 1 : -1 : 0;
  });
}, Kr = (e, t, l) => e.filter(
  (a) => Object.entries(a).filter((o) => {
    const [n, s] = o;
    return !s || n[0] === "_" || l && l.length > 0 && !l.includes(n) ? !1 : (typeof s == "object" ? JSON.stringify(Object.values(s)) : s.toString()).toLowerCase().includes(t.toLowerCase());
  }).length > 0
), Jr = (e, t, l, a, o) => {
  let n = e.value;
  const s = "isFilterableTable" in l && l.isFilterableTable.value === !0 && t.filter;
  (s && !a.value || s && a.value && l.noProviderFilteringBoolean.value) && (n = Kr(n, t.filter, t.filterable));
  const r = "isSortable" in l && l.isSortable.value === !0;
  return (r && !a.value || r && a.value && l.noProviderSortingBoolean.value) && (n = Xr(
    t.fields,
    n,
    o == null ? void 0 : o.value,
    l.sortDescBoolean.value,
    t.sortCompare
  )), n;
}, Yr = (e, t, l, a) => {
  const o = R(), n = R(e.items ?? []), s = R([0, n.value.length]), r = w(() => {
    const b = t.requireItemsMapping.value ? Jr(n, e, t, l, a) : l.value ? n.value : e.items ?? [];
    if (e.perPage !== void 0) {
      const c = ((e.currentPage ?? 0) - 1) * e.perPage, h = c + e.perPage > b.length ? b.length : c + e.perPage;
      s.value = [c, h];
    }
    return b;
  }), i = w(() => e.perPage === void 0 || l.value && !t.noProviderPagingBoolean.value ? r.value : r.value.slice(s.value[0], s.value[1]));
  return {
    internalItems: n,
    computedItems: r,
    updateInternalItems: async (b) => {
      try {
        return n.value = b, n.value;
      } catch {
        return;
      }
    },
    filteredHandler: o,
    notifyFilteredItems: () => {
      o.value && o.value(r.value);
    },
    computedDisplayItems: i
  };
}, Zr = "top-right", tn = zo(() => {
  const e = R([]);
  return { toasts: e, show: (...[a, o]) => {
    const n = { pos: Zr };
    typeof a == "string" ? Object.assign(n, o, {
      body: a,
      value: (o == null ? void 0 : o.value) || 5e3
    }) : Object.assign(n, a, { value: a.value || 5e3 });
    const s = Symbol();
    return e.value.push({ ...n, self: s }), s;
  }, hide: (a) => {
    const o = e.value.findIndex((n) => n.self === a);
    o !== -1 && e.value.splice(o, 1);
  } };
}), Qr = ["id"], ei = ["innerHTML"], ti = ["innerHTML"], tl = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BPopover",
  props: {
    modelValue: { type: [String, Boolean], default: !1 },
    container: { default: void 0 },
    target: { default: null },
    reference: { default: null },
    content: { default: void 0 },
    id: { default: void 0 },
    title: { default: void 0 },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    click: { type: [String, Boolean], default: !1 },
    manual: { type: [String, Boolean], default: !1 },
    variant: { default: null },
    offset: { default: null },
    customClass: { default: "" },
    placement: { default: "top" },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    noFlip: { type: [String, Boolean], default: !1 },
    noShift: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    noAutoClose: { type: [String, Boolean], default: !1 },
    hide: { type: [String, Boolean] },
    realtime: { type: [String, Boolean], default: !1 },
    inline: { type: [String, Boolean], default: !1 },
    tooltip: { type: [String, Boolean], default: !1 },
    html: { type: [String, Boolean], default: !1 },
    noninteractive: { type: [String, Boolean], default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = u(() => a.modelValue), n = R(o.value), s = R(o.value);
    Ot(() => {
      l("update:modelValue", n.value);
    }), re(o, () => {
      o.value !== n.value && (o.value ? ee() : E(new Event("update:modelValue")));
    });
    const r = ke(() => a.id, "popover"), i = u(() => a.click), d = u(() => a.manual), y = u(() => a.noShift), b = u(() => a.noFlip), c = u(() => a.noFade), h = u(() => a.noAutoClose), S = u(() => a.noHide), B = u(() => a.realtime), F = u(() => a.inline), C = u(() => a.tooltip), V = u(() => a.noninteractive), T = u(() => a.html), $ = R(!1), m = R(null), k = R(null), f = R(null), _ = R(null), L = R(null), v = w(
      () => a.title ? $t(a.title, kt) : ""
    ), I = w(
      () => a.content ? $t(a.content, kt) : ""
    ), H = N(() => a.placement.startsWith("auto")), O = Be(N(() => a.offset ?? NaN)), q = w(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const Y = a.offset !== null ? O.value : C.value ? 0 : 10, se = [$o(Y)];
      return b.value === !1 && !H.value && se.push(Co()), H.value && se.push(
        Rs({
          alignment: a.placement.split("-")[1] || void 0
        })
      ), y.value === !1 && se.push(_o()), S.value === !1 && se.push(Ms({ padding: 10 })), F.value === !0 && se.push(js()), se.push(ur({ element: f, padding: 10 })), se;
    }), Q = N(
      () => H.value ? void 0 : a.placement
    ), { floatingStyles: X, middlewareData: ue, placement: ae, update: me } = Io(k, m, {
      placement: Q,
      middleware: q,
      strategy: Ee(N(a, "strategy")),
      whileElementsMounted: (...Y) => No(...Y, { animationFrame: B.value })
    }), te = R({ position: "absolute" });
    re(ue, () => {
      var Y;
      if (S.value === !1 && ((Y = ue.value.hide) != null && Y.referenceHidden ? $.value = !0 : $.value = !1), ue.value.arrow) {
        const { x: se, y: $e } = ue.value.arrow;
        te.value = {
          position: "absolute",
          top: $e ? `${$e}px` : "",
          left: se ? `${se}px` : ""
        };
      }
    });
    const de = w(() => {
      const Y = C.value ? "tooltip" : "popover";
      return [
        Y,
        `b-${Y}`,
        {
          [`b-${Y}-${a.variant}`]: a.variant !== null,
          show: n.value && !$.value,
          "pe-none": !n.value,
          fade: !c.value,
          "d-none": !n.value && c.value,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${Y}-${li(ae.value)}`]: ae.value !== void 0
        }
      ];
    }), { isOutside: ye } = $l(m), { isOutside: G } = $l(_), oe = (Y) => {
      const se = Y ?? new Event("click");
      n.value ? E(se) : ee();
    }, fe = (Y, se = {}) => new Ft(Y, {
      cancelable: !1,
      target: m.value || null,
      relatedTarget: null,
      trigger: null,
      ...se,
      componentId: r.value
    });
    let W;
    const ee = () => {
      const Y = fe("show", { cancelable: !0 });
      if (l("show", Y), Y.defaultPrevented) {
        l("show-prevented");
        return;
      }
      s.value = !0, _e(() => {
        var se;
        me(), W = setTimeout(
          () => {
            me(), n.value = !0, _e(() => {
              l("shown", fe("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((se = a.delay) == null ? void 0 : se.show) || 0
        );
      });
    }, E = (Y) => {
      var it;
      const se = fe("hide", { cancelable: !0 });
      if (l("hide", se), se.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      W && (clearTimeout(W), W = void 0);
      const $e = typeof a.delay == "number" ? a.delay : ((it = a.delay) == null ? void 0 : it.hide) || 0;
      setTimeout(() => {
        var De, Ce;
        (Y == null ? void 0 : Y.type) === "click" || (Y == null ? void 0 : Y.type) === "forceHide" || (Y == null ? void 0 : Y.type) === "update:modelValue" && d.value || !V.value && ye.value && G.value && !((De = m.value) != null && De.contains(document == null ? void 0 : document.activeElement)) && !((Ce = _.value) != null && Ce.contains(document == null ? void 0 : document.activeElement)) || V.value && G.value ? (n.value = !1, _e(() => {
          setTimeout(
            () => {
              s.value = !1;
            },
            m.value ? wa(m.value) : 150
          ), l("hidden", fe("hidden"));
        })) : setTimeout(
          () => {
            E(Y);
          },
          $e < 50 ? 50 : $e
        );
      }, $e);
    };
    t({
      hide: E,
      show: ee,
      toggle: oe
    });
    const j = (Y) => {
      const se = g(Y);
      if (se) {
        if (typeof se == "string") {
          const $e = document.getElementById(se);
          return $e || void 0;
        }
        return se.$el ? se.$el : se;
      }
    }, U = () => {
      var Y;
      if (a.target) {
        const se = j(a.target);
        se ? _.value = se : console.warn("Target element not found", a.target);
      } else
        _.value = (Y = L.value) == null ? void 0 : Y.nextElementSibling;
      if (a.reference) {
        const se = j(a.reference);
        se ? k.value = se : console.warn("Reference element not found", a.reference);
      } else
        k.value = _.value;
      !_.value || d.value || Ra && (_.value.addEventListener("forceHide", E), i.value && _.value.addEventListener("click", oe), !i.value && _.value.addEventListener("pointerenter", ee), !i.value && _.value.addEventListener("pointerleave", E), !i.value && _.value.addEventListener("focus", ee), !i.value && _.value.addEventListener("blur", E));
    }, ce = () => {
      _.value && (_.value.removeEventListener("forceHide", E), _.value.removeEventListener("click", oe), _.value.removeEventListener("pointerenter", ee), _.value.removeEventListener("pointerleave", E), _.value.removeEventListener("focus", ee), _.value.removeEventListener("blur", E));
    };
    return jo(
      m,
      () => {
        n.value && i.value && !h.value && !d.value && E(new Event("clickOutside"));
      },
      { ignore: [_] }
    ), re([() => a.click, () => a.target, () => a.reference], () => {
      ce(), U();
    }), Ze(U), Ia(ce), (Y, se) => (p(), P(ve, null, [
      Z("span", {
        ref_key: "placeholder",
        ref: L
      }, null, 512),
      A(Y.$slots, "target", {
        show: ee,
        hide: E,
        toggle: oe,
        showState: n.value
      }),
      be(va, {
        tag: "Teleport",
        to: Y.container,
        skip: !Y.container
      }, {
        default: D(() => [
          s.value ? (p(), P("div", le({
            key: 0,
            id: Y.id
          }, Y.$attrs, {
            ref_key: "element",
            ref: m,
            class: de.value,
            role: "tooltip",
            tabindex: "-1",
            style: g(X)
          }), [
            Z("div", {
              ref_key: "arrow",
              ref: f,
              class: z(`${g(C) ? "tooltip" : "popover"}-arrow`),
              style: xe(te.value),
              "data-popper-arrow": ""
            }, null, 6),
            Y.title || Y.$slots.title ? (p(), P(ve, { key: 0 }, [
              g(T) ? (p(), P("div", {
                key: 1,
                class: z(g(C) ? "tooltip-inner" : "popover-header"),
                innerHTML: v.value
              }, null, 10, ei)) : (p(), P("div", {
                key: 0,
                class: z(g(C) ? "tooltip-inner" : "popover-header")
              }, [
                A(Y.$slots, "title", {}, () => [
                  ie(J(Y.title), 1)
                ])
              ], 2))
            ], 64)) : K("", !0),
            g(C) && !Y.$slots.title && !Y.title || !g(C) ? (p(), P(ve, { key: 1 }, [
              g(T) ? (p(), P("div", {
                key: 1,
                class: z(g(C) ? "tooltip-inner" : "popover-body"),
                innerHTML: I.value
              }, null, 10, ti)) : (p(), P("div", {
                key: 0,
                class: z(g(C) ? "tooltip-inner" : "popover-body")
              }, [
                A(Y.$slots, "default", {}, () => [
                  ie(J(Y.content), 1)
                ])
              ], 2))
            ], 64)) : K("", !0)
          ], 16, Qr)) : K("", !0)
        ]),
        _: 3
      }, 8, ["to", "skip"])
    ], 64));
  }
}), ai = ({
  top: e,
  end: t,
  start: l,
  alignCenter: a,
  alignEnd: o
}) => {
  const n = e ? "top" : l ? "left" : t ? "right" : "bottom", s = o ? "end" : a ? null : "start";
  return `${n}${s ? `-${s}` : ""}`;
}, li = (e) => {
  const [t] = e.split("-");
  switch (t) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return t;
  }
}, zt = (e) => typeof e != "object" || e.active !== !1, la = (e, t) => {
  if (!zt(e))
    return {};
  const a = typeof e > "u" || typeof e == "object" && !e.title && !e.content, o = t.getAttribute("title") || t.getAttribute("data-original-title");
  return a ? o ? (t.removeAttribute("title"), t.setAttribute("data-original-title", o), {
    content: $t(o, kt)
  }) : {} : typeof e == "string" ? {
    content: $t(e, kt)
  } : {
    title: e != null && e.title ? $t(e == null ? void 0 : e.title, kt) : void 0,
    content: e != null && e.content ? $t(e == null ? void 0 : e.content, kt) : void 0
  };
}, Tt = (e, t) => ({
  target: t,
  modelValue: e.modifiers.show,
  inline: e.modifiers.inline,
  click: e.modifiers.click,
  realtime: e.modifiers.realtime,
  placement: e.modifiers.left ? "left" : e.modifiers.right ? "right" : e.modifiers.bottom ? "bottom" : e.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof e.value == "object" ? e.value : {},
  title: null,
  content: null
}), oa = (e, t) => {
  var a;
  const l = document.createElement("span");
  t.modifiers.body ? document.body.appendChild(l) : t.modifiers.child ? e.appendChild(l) : (a = e.parentNode) == null || a.insertBefore(l, e.nextSibling), e.$__app = Gn({ render: () => {
    var o;
    return ge(tl, { ...(o = e.$__state) == null ? void 0 : o.value });
  } }), e.$__app.mount(l), e.$__element = l;
}, an = (e) => {
  var l;
  const t = e.$__element;
  (l = e.$__app) == null || l.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {
    t == null || t.remove();
  }, 0), delete e.$__element;
}, _l = (e, t) => {
  const { all: l, ...a } = e, o = {};
  l && t.forEach((s) => {
    o[s] = l;
  });
  const n = { ...o, ...a };
  return Object.entries(n).filter(([s, r]) => !!r && t.includes(s)).map(([s]) => s);
}, oi = ["id"], ni = /* @__PURE__ */ x({
  __name: "BAccordion",
  props: {
    flush: { type: [String, Boolean], default: !1 },
    free: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    modelValue: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const l = e, a = Se(l, "modelValue", t, { passive: !0 }), o = ke(() => l.id, "accordion"), n = u(() => l.flush), s = u(() => l.free), r = w(() => ({
      "accordion-flush": n.value
    }));
    return Ue(go, {
      openItem: Ee(a),
      free: s,
      setOpenItem: (i) => {
        a.value = i;
      }
    }), (i, d) => (p(), P("div", {
      id: g(o),
      class: z(["accordion", r.value])
    }, [
      A(i.$slots, "default")
    ], 10, oi));
  }
}), ln = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BCollapse",
  props: {
    id: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    toggle: { type: [String, Boolean], default: !1 },
    horizontal: { type: [String, Boolean], default: !1 },
    visible: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = (m, k = {}) => new Ft(m, {
      cancelable: !1,
      target: c.value || null,
      relatedTarget: null,
      trigger: null,
      ...k,
      componentId: b.value
    }), n = Se(a, "modelValue", l, { passive: !0 }), s = u(n), r = u(() => a.toggle), i = u(() => a.horizontal), d = u(() => a.isNav), y = u(() => a.visible), b = ke(() => a.id, "collapse"), c = R(null), h = R(!1), S = R(s.value), B = w(() => ({
      show: S.value,
      "navbar-collapse": d.value,
      collapsing: h.value,
      closing: S.value && !s.value,
      "collapse-horizontal": i.value
    })), F = () => {
      n.value = !1;
    }, C = () => {
      n.value = !0;
    }, V = () => {
      n.value = !s.value;
    }, T = () => {
      S.value = !0, h.value = !0;
      const m = o("show", { cancelable: !0 });
      if (l("show", m), m.defaultPrevented) {
        l("show-prevented");
        return;
      }
      _e(() => {
        c.value !== null && (i.value ? c.value.style.width = `${c.value.scrollWidth}px` : c.value.style.height = `${c.value.scrollHeight}px`, setTimeout(() => {
          h.value = !1, l("shown"), c.value !== null && (c.value.style.height = "", c.value.style.width = "");
        }, wa(c.value)));
      });
    }, $ = () => {
      const m = o("hide", { cancelable: !0 });
      if (l("hide", m), m.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      c.value !== null && (i.value ? c.value.style.width = `${c.value.scrollWidth}px` : c.value.style.height = `${c.value.scrollHeight}px`, c.value.offsetHeight, h.value = !0, _e(() => {
        c.value !== null && (c.value.style.height = "", c.value.style.width = "", setTimeout(() => {
          S.value = !1, h.value = !1, l("hidden");
        }, wa(c.value)));
      }));
    };
    return re([n, S], () => {
      if (s.value === !0) {
        if (S.value)
          return;
        T();
        return;
      }
      $();
    }), Ze(() => {
      c.value !== null && !s.value && r.value && _e(() => {
        n.value = !0;
      });
    }), y.value && (n.value = !0, S.value = !0), re(y, (m) => {
      m ? C() : F();
    }), we(c, "bv-toggle", () => {
      n.value = !s.value;
    }), t({
      close: F,
      open: C,
      toggle: V,
      visible: Ee(S),
      isNav: d
    }), Ue(ja, {
      id: b,
      close: F,
      open: C,
      toggle: V,
      visible: Ee(S),
      isNav: d
    }), (m, k) => (p(), P(ve, null, [
      A(m.$slots, "header", {
        id: g(b),
        visible: g(s),
        toggle: V,
        open: C,
        close: F
      }),
      (p(), M(ne(m.tag), le({
        id: g(b),
        ref_key: "element",
        ref: c,
        class: ["collapse", B.value],
        "is-nav": g(d)
      }, m.$attrs), {
        default: D(() => [
          A(m.$slots, "default", {
            visible: g(s),
            toggle: m.toggle,
            open: C,
            close: F
          })
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      A(m.$slots, "footer", {
        id: g(b),
        visible: g(s),
        toggle: V,
        open: C,
        close: F
      })
    ], 64));
  }
}), si = { class: "accordion-item" }, ri = ["aria-expanded", "aria-controls", "onClick"], ii = { class: "accordion-body" }, ui = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BAccordionItem",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    headerTag: { default: "h2" },
    tag: { default: void 0 },
    toggle: { type: [String, Boolean], default: void 0 },
    horizontal: { type: [String, Boolean], default: void 0 },
    visible: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const l = e, a = Se(l, "modelValue", t, { passive: !0 }), o = Le(go, null), n = ke(() => l.id, "accordion_item");
    return Ze(() => {
      a.value && !(o != null && o.free.value) && (o == null || o.setOpenItem(n.value)), !a.value && (o == null ? void 0 : o.openItem.value) === n.value && (a.value = !0);
    }), re(
      () => o == null ? void 0 : o.openItem.value,
      () => a.value = (o == null ? void 0 : o.openItem.value) === n.value && !(o != null && o.free.value)
    ), re(a, () => {
      a.value && !(o != null && o.free.value) && (o == null || o.setOpenItem(n.value));
    }), (s, r) => (p(), P("div", si, [
      be(ln, le({
        id: g(n),
        modelValue: g(a),
        "onUpdate:modelValue": r[0] || (r[0] = (i) => La(a) ? a.value = i : null),
        class: "accordion-collapse"
      }, s.$attrs, {
        "aria-labelledby": `${g(n)}-heading`,
        tag: s.tag,
        toggle: s.toggle,
        horizontal: s.horizontal,
        visible: s.visible,
        "is-nav": s.isNav,
        onShow: r[1] || (r[1] = (i) => t("show", i)),
        onShown: r[2] || (r[2] = (i) => t("shown")),
        onHide: r[3] || (r[3] = (i) => t("hide", i)),
        onHidden: r[4] || (r[4] = (i) => t("hidden")),
        onHidePrevented: r[5] || (r[5] = (i) => t("hide-prevented")),
        onShowPrevented: r[6] || (r[6] = (i) => t("show-prevented"))
      }), {
        header: D(({ visible: i, toggle: d }) => [
          (p(), M(ne(s.headerTag), {
            id: `${g(n)}-heading`,
            class: "accordion-header"
          }, {
            default: D(() => [
              Z("button", {
                class: z(["accordion-button", { collapsed: !i }]),
                type: "button",
                "aria-expanded": i ? "true" : "false",
                "aria-controls": g(n),
                onClick: d
              }, [
                A(s.$slots, "title", {}, () => [
                  ie(J(s.title), 1)
                ])
              ], 10, ri)
            ]),
            _: 2
          }, 1032, ["id"]))
        ]),
        default: D(() => [
          Z("div", ii, [
            A(s.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, ["id", "modelValue", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ]));
  }
}), Pt = /* @__PURE__ */ x({
  __name: "BTransition",
  props: {
    appear: { type: [String, Boolean], default: !1 },
    mode: { default: void 0 },
    noFade: { type: [String, Boolean], default: !1 },
    transProps: { default: void 0 }
  },
  setup(e) {
    const t = e, l = u(() => t.appear), a = u(() => t.noFade), o = w(() => {
      const r = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, i = {
        ...r,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return a.value ? r : i;
    }), n = w(() => ({ mode: t.mode, css: !0, ...o.value })), s = w(
      () => t.transProps !== void 0 ? {
        // Order matters here since the props.transProps would get overwritten if it came first
        // But the goal of props.transProps is to overwrite base properties
        ...n.value,
        ...t.transProps
      } : l.value ? {
        ...n.value,
        appear: !0,
        appearActiveClass: o.value.enterActiveClass,
        appearToClass: o.value.enterToClass
      } : n.value
    );
    return (r, i) => (p(), M(Wn, Ve(Pe(s.value)), {
      default: D(() => [
        A(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
const di = ["type", "disabled", "aria-label"], Nt = /* @__PURE__ */ x({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: [String, Boolean], default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = u(() => l.disabled);
    return (o, n) => (p(), P("button", {
      type: o.type,
      class: "btn-close",
      disabled: g(a),
      "aria-label": o.ariaLabel,
      onClick: n[0] || (n[0] = (s) => t("click", s))
    }, null, 8, di));
  }
}), ci = {
  key: 0,
  class: "visually-hidden"
}, pa = /* @__PURE__ */ x({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = Oe(), a = u(() => t.small), o = w(() => [
      `spinner-${t.type}`,
      {
        [`spinner-${t.type}-sm`]: a.value,
        [`text-${t.variant}`]: t.variant !== null
      }
    ]), n = N(() => !Ae(l.label));
    return (s, r) => (p(), M(ne(s.tag), {
      class: z(o.value),
      role: s.label || n.value ? s.role : null,
      "aria-hidden": s.label || n.value ? null : !0
    }, {
      default: D(() => [
        s.label || n.value ? (p(), P("span", ci, [
          A(s.$slots, "label", {}, () => [
            ie(J(s.label), 1)
          ])
        ])) : K("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), Tl = "active", tt = /* @__PURE__ */ x({
  __name: "BLink",
  props: {
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    event: { default: "click" },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: null },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = Zl(), o = u(() => l.active), n = u(() => l.icon);
    u(() => l.append);
    const s = u(() => l.disabled);
    u(() => l.replace);
    const r = Le(ja, null), i = Le(qa, null), d = Et(), y = w(() => {
      const F = l.routerComponentName.split("-").map((V) => V.charAt(0).toUpperCase() + V.slice(1)).join("");
      return !((d == null ? void 0 : d.appContext.app.component(F)) !== void 0) || s.value || !l.to ? "a" : l.routerComponentName;
    }), b = w(() => {
      const F = "#";
      if (l.href)
        return l.href;
      if (typeof l.to == "string")
        return l.to || F;
      const C = l.to;
      if (Object.prototype.toString.call(C) === "[object Object]" && (C.path || C.query || C.hash)) {
        const V = C.path || "", T = C.query ? `?${Object.keys(C.query).map((m) => `${m}=${C.query[m]}`).join("=")}` : "", $ = !C.hash || C.hash.charAt(0) === "#" ? C.hash || "" : `#${C.hash}`;
        return `${V}${T}${$}` || F;
      }
      return F;
    }), c = w(() => ({
      [`link-${l.variant}`]: l.variant !== null,
      [`link-opacity-${l.opacity}`]: l.opacity !== void 0,
      [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,
      [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,
      [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,
      [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,
      [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,
      [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,
      "icon-link": n.value === !0
    })), h = w(() => ({
      class: c.value,
      to: l.to,
      href: b.value,
      target: l.target,
      rel: l.target === "_blank" && l.rel === void 0 ? "noopener" : l.rel || void 0,
      tabindex: s.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": s.value ? !0 : null
    })), S = w(() => ({
      [Tl]: o.value,
      disabled: s.value
    })), B = (F) => {
      var C, V, T;
      if (s.value) {
        F.preventDefault(), F.stopImmediatePropagation();
        return;
      }
      (((C = r == null ? void 0 : r.isNav) == null ? void 0 : C.value) === !0 && i === null || i !== null && ((V = i.autoClose) == null ? void 0 : V.value) === !0) && ((T = r == null ? void 0 : r.close) == null || T.call(r)), t("click", F);
    };
    return (F, C) => y.value === "router-link" ? (p(), M(ne(y.value), le({ key: 0 }, h.value, { custom: "" }), {
      default: D(({ href: V, navigate: T, isActive: $ }) => [
        (p(), M(ne(F.routerTag), le({
          href: V,
          class: [(g(o) ?? $) && `${F.activeClass} ${Tl}`]
        }, F.$attrs, {
          onClick: (m) => {
            T(m), B(m);
          }
        }), {
          default: D(() => [
            A(F.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (p(), M(ne(y.value), le({
      key: 1,
      class: S.value
    }, h.value, { onClick: B }), {
      default: D(() => [
        A(F.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), ut = /* @__PURE__ */ x({
  __name: "BButton",
  props: {
    pill: { type: [String, Boolean], default: !1 },
    pressed: { type: [String, Boolean], default: void 0 },
    size: { default: "md" },
    squared: { type: [String, Boolean], default: !1 },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    loading: { type: [String, Boolean], default: !1 },
    loadingFill: { type: [String, Boolean], default: !1 },
    block: { type: [String, Boolean], default: !1 },
    loadingText: { default: "Loading..." },
    active: { type: [String, Boolean], default: !1 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    event: { default: "click" },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: "_self" },
    to: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const l = e, a = Se(l, "pressed", t), o = u(() => l.active), n = u(() => l.block), s = u(() => l.disabled), r = u(() => l.pill), i = u(() => l.pressed), d = u(() => l.squared), y = u(() => l.loading), b = u(() => l.loadingFill), { computedLink: c } = ht(l), h = N(() => typeof i.value == "boolean"), S = N(
      () => l.tag === "button" && l.href === void 0 && l.to === void 0
    ), B = N(() => l.to !== void 0), F = N(() => l.href !== void 0 ? !1 : !S.value), C = w(() => [
      [`btn-${l.size}`],
      {
        [`btn-${l.variant}`]: l.variant !== null,
        "btn-block": n.value,
        active: o.value || i.value,
        "rounded-pill": r.value,
        "rounded-0": d.value,
        disabled: s.value
      }
    ]), V = N(() => B.value ? tt : l.href ? "a" : l.tag), T = ($) => {
      if (s.value) {
        $.preventDefault(), $.stopPropagation();
        return;
      }
      t("click", $), h.value && (a.value = !i.value);
    };
    return ($, m) => (p(), M(ne(V.value), {
      class: z(["btn", C.value]),
      "aria-disabled": F.value ? g(s) : null,
      "aria-pressed": h.value ? g(i) : null,
      autocomplete: h.value ? "off" : null,
      disabled: S.value ? g(s) : null,
      href: $.href,
      rel: g(c) ? $.rel : null,
      role: F.value || g(c) ? "button" : null,
      target: g(c) ? $.target : null,
      type: S.value ? $.type : null,
      to: S.value ? null : $.to,
      append: g(c) ? $.append : null,
      "active-class": B.value ? $.activeClass : null,
      event: B.value ? $.event : null,
      replace: B.value ? $.replace : null,
      "router-component-name": B.value ? $.routerComponentName : null,
      "router-tag": B.value ? $.routerTag : null,
      onClick: T
    }, {
      default: D(() => [
        g(y) ? A($.$slots, "loading", { key: 0 }, () => [
          g(b) ? K("", !0) : (p(), P(ve, { key: 0 }, [
            ie(J($.loadingText), 1)
          ], 64)),
          A($.$slots, "loading-spinner", {}, () => [
            be(pa, {
              small: $.size !== "lg",
              label: g(b) ? $.loadingText : void 0
            }, null, 8, ["small", "label"])
          ])
        ]) : A($.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "aria-disabled", "aria-pressed", "autocomplete", "disabled", "href", "rel", "role", "target", "type", "to", "append", "active-class", "event", "replace", "router-component-name", "router-tag"]));
  }
}), fi = /* @__PURE__ */ x({
  __name: "BAlert",
  props: {
    closeVariant: { default: "secondary" },
    closeClass: { default: void 0 },
    closeLabel: { default: "Close" },
    closeContent: { default: void 0 },
    noHoverPause: { type: [String, Boolean], default: !1 },
    dismissible: { type: [String, Boolean], default: !1 },
    fade: { type: [String, Boolean], default: !1 },
    modelValue: { type: [Boolean, Number], default: !1 },
    variant: { default: "info" },
    immediate: { type: [String, Boolean], default: !0 },
    interval: { default: 1e3 },
    showOnPause: { type: [String, Boolean], default: !0 }
  },
  emits: ["close", "closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Oe(), n = R(null), s = Se(a, "modelValue", l), r = Za(n), i = u(() => a.dismissible), d = u(() => a.fade), y = u(() => a.immediate), b = u(() => a.showOnPause), c = u(() => a.noHoverPause), h = Be(() => a.interval), S = N(() => !Ae(o.close)), B = N(() => typeof s.value == "boolean" ? 0 : s.value), F = w(() => ({
      [`alert-${a.variant}`]: a.variant !== null,
      "alert-dismissible": i.value
    })), C = w(() => [a.closeClass, { "btn-close-custom": S.value }]), {
      isActive: V,
      pause: T,
      restart: $,
      resume: m,
      stop: k,
      isPaused: f,
      value: _
    } = Wo(B, h, {
      immediate: typeof s.value == "number" && y.value
    }), L = N(
      () => typeof s.value == "boolean" ? s.value : V.value || b.value && f.value
    ), v = w(() => ({
      variant: S.value ? a.closeVariant : void 0,
      class: C.value
    }));
    Ot(() => {
      l("close-countdown", _.value);
    });
    const I = () => {
      l("close"), typeof s.value == "boolean" ? s.value = !1 : (s.value = 0, k()), l("closed");
    }, H = () => {
      c.value || T();
    };
    return re(r, (O) => {
      if (O) {
        H();
        return;
      }
      m();
    }), Ia(k), t({
      pause: T,
      resume: m,
      restart: $,
      stop: k
    }), (O, q) => (p(), M(Pt, {
      "no-fade": !g(d),
      "trans-props": { enterToClass: "show" }
    }, {
      default: D(() => [
        L.value ? (p(), P("div", {
          key: 0,
          ref_key: "element",
          ref: n,
          class: z(["alert", F.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true"
        }, [
          A(O.$slots, "default", {}, void 0, !0),
          g(i) ? (p(), P(ve, { key: 0 }, [
            S.value || O.closeContent ? (p(), M(ut, le({ key: 0 }, v.value, { onClick: I }), {
              default: D(() => [
                A(O.$slots, "close", {}, () => [
                  ie(J(O.closeContent), 1)
                ], !0)
              ]),
              _: 3
            }, 16)) : (p(), M(Nt, le({
              key: 1,
              "aria-label": O.closeLabel
            }, v.value, { onClick: I }), null, 16, ["aria-label"]))
          ], 64)) : K("", !0)
        ], 2)) : K("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
});
const ma = (e, t) => {
  const l = e.__vccOpts || e;
  for (const [a, o] of t)
    l[a] = o;
  return l;
}, vi = /* @__PURE__ */ ma(fi, [["__scopeId", "data-v-dd6c5e17"]]), pi = {
  key: 0,
  class: "b-avatar-custom"
}, mi = {
  key: 1,
  class: "b-avatar-img"
}, gi = ["src", "alt"], yi = { key: 1 }, Ta = (e) => {
  const t = typeof e == "string" && Yn(e) ? Kt(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
}, bi = /* @__PURE__ */ x({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    badge: { type: [Boolean, String], default: !1 },
    badgeLeft: { type: [String, Boolean], default: !1 },
    badgeOffset: { default: void 0 },
    badgeTop: { type: [String, Boolean], default: !1 },
    badgeVariant: { default: "primary" },
    badgeTextVariant: { default: null },
    badgeBgVariant: { default: null },
    button: { type: [String, Boolean], default: !1 },
    buttonType: { default: "button" },
    icon: { type: [String, Boolean], default: void 0 },
    rounded: { type: [Boolean, String], default: "circle" },
    size: { default: void 0 },
    square: { type: [String, Boolean], default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: "secondary" },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const l = e, a = Oe(), { computedLink: o, computedLinkProps: n } = ht(l), s = Le(mo, null), r = ["sm", null, "lg"], i = 0.4, d = i * 0.7, y = u(() => l.badgeLeft), b = u(() => l.badgeTop), c = u(() => l.button), h = u(() => l.disabled), S = u(() => l.square), B = N(() => !Ae(a.default)), F = N(() => !Ae(a.badge)), C = N(() => !!l.badge || l.badge === "" || F.value), V = N(() => (s == null ? void 0 : s.size.value) ?? Ta(l.size)), T = N(() => (s == null ? void 0 : s.variant.value) ?? l.variant), $ = N(() => (s == null ? void 0 : s.rounded.value) ?? l.rounded), m = qe(() => ({
      variant: l.badgeVariant,
      bgVariant: l.badgeBgVariant,
      textVariant: l.badgeTextVariant
    })), k = N(() => l.badge === !0 ? "" : l.badge), f = N(() => (s == null ? void 0 : s.textVariant.value) ?? l.textVariant), _ = N(() => (s == null ? void 0 : s.bgVariant.value) ?? l.bgVariant), L = qe(() => ({
      bgVariant: _.value,
      textVariant: f.value,
      variant: T.value
    })), v = w(() => [
      L.value,
      {
        [`b-avatar-${l.size}`]: !!l.size && r.indexOf(Ta(l.size)) !== -1,
        badge: !c.value && T.value !== null && B.value,
        rounded: $.value === "" || $.value === !0,
        "rounded-circle": !S.value && $.value === "circle",
        "rounded-0": S.value || $.value === "0",
        "rounded-1": !S.value && $.value === "sm",
        "rounded-3": !S.value && $.value === "lg",
        "rounded-top": !S.value && $.value === "top",
        "rounded-bottom": !S.value && $.value === "bottom",
        "rounded-start": !S.value && $.value === "left",
        "rounded-end": !S.value && $.value === "right",
        btn: c.value,
        [`btn-${T.value}`]: c.value ? T.value !== null : !1
      }
    ]), I = w(() => {
      const ae = l.badgeOffset || "0px";
      return {
        fontSize: (r.indexOf(V.value || null) === -1 ? `calc(${V.value} * ${d})` : "") || "",
        top: b.value ? ae : "",
        bottom: b.value ? "" : ae,
        left: y.value ? ae : "",
        right: y.value ? "" : ae
      };
    }), H = w(() => {
      const ae = r.indexOf(V.value || null) === -1 ? `calc(${V.value} * ${i})` : null;
      return ae ? { fontSize: ae } : {};
    }), O = w(() => {
      var te;
      const ae = ((te = s == null ? void 0 : s.overlapScale) == null ? void 0 : te.value) || 0, me = V.value && ae ? `calc(${V.value} * -${ae})` : null;
      return me ? { marginLeft: me, marginRight: me } : {};
    }), q = N(
      () => o.value ? tt : c.value ? "button" : "span"
    ), Q = w(() => ({
      ...O.value,
      width: V.value ?? void 0,
      height: V.value ?? void 0
    })), X = (ae) => {
      !h.value && (o.value || c.value) && t("click", ae);
    }, ue = (ae) => {
      t("img-error", ae);
    };
    return (ae, me) => (p(), M(ne(q.value), le({
      class: ["b-avatar", v.value],
      style: Q.value
    }, g(n), {
      type: g(c) && !g(o) ? l.buttonType : void 0,
      disabled: g(h) || null,
      onClick: X
    }), {
      default: D(() => [
        B.value ? (p(), P("span", pi, [
          A(ae.$slots, "default")
        ])) : ae.src ? (p(), P("span", mi, [
          Z("img", {
            src: ae.src,
            alt: ae.alt,
            onError: ue
          }, null, 40, gi)
        ])) : ae.text ? (p(), P("span", {
          key: 2,
          class: "b-avatar-text",
          style: xe(H.value)
        }, J(ae.text), 5)) : K("", !0),
        C.value ? (p(), P("span", {
          key: 3,
          class: z(["b-avatar-badge", g(m)]),
          style: xe(I.value)
        }, [
          F.value ? A(ae.$slots, "badge", { key: 0 }) : (p(), P("span", yi, J(k.value), 1))
        ], 6)) : K("", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "type", "disabled"]));
  }
}), hi = /* @__PURE__ */ x({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    square: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => t.square), a = Be(() => t.overlap), o = w(() => Ta(t.size)), n = w(() => Math.min(Math.max(a.value, 0), 1) / 2), s = w(() => {
      const r = o.value ? `calc(${o.value} * ${n.value})` : null;
      return r ? { paddingLeft: r, paddingRight: r } : {};
    });
    return Ue(mo, {
      overlapScale: n,
      size: N(() => t.size),
      square: l,
      rounded: N(() => t.rounded),
      variant: N(() => t.variant),
      bgVariant: N(() => t.bgVariant),
      textVariant: N(() => t.textVariant)
    }), (r, i) => (p(), M(ne(r.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: D(() => [
        Z("div", {
          class: "b-avatar-group-inner",
          style: xe(s.value)
        }, [
          A(r.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), Bi = /* @__PURE__ */ x({
  __name: "BBadge",
  props: {
    pill: { type: [String, Boolean], default: !1 },
    tag: { default: "span" },
    textIndicator: { type: [String, Boolean], default: !1 },
    dotIndicator: { type: [String, Boolean], default: !1 },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: "secondary" },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => t.pill), a = u(() => t.textIndicator), o = u(() => t.dotIndicator), n = u(() => t.active), s = u(() => t.disabled), r = qe(t), { computedLink: i, computedLinkProps: d } = ht(t, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), y = N(() => i.value ? tt : t.tag), b = w(() => [
      r.value,
      {
        active: n.value,
        disabled: s.value,
        "rounded-pill": l.value,
        "position-absolute top-0 start-100 translate-middle": a.value || o.value,
        "p-2 border border-light rounded-circle": o.value,
        "text-decoration-none": i.value
      }
    ]);
    return (c, h) => (p(), M(ne(y.value), le({
      class: ["badge", b.value]
    }, g(d)), {
      default: D(() => [
        A(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), on = /* @__PURE__ */ x({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = u(() => l.active), o = u(() => l.disabled), n = w(() => ({
      active: a.value
    })), s = N(() => a.value ? "span" : tt), r = N(() => a.value ? l.ariaCurrent : void 0), i = w(
      () => s.value !== "span" ? Da(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    ), d = (y) => {
      if (o.value || a.value) {
        y.preventDefault(), y.stopImmediatePropagation();
        return;
      }
      o.value || t("click", y);
    };
    return (y, b) => (p(), P("li", {
      class: z(["breadcrumb-item", n.value])
    }, [
      (p(), M(ne(s.value), le({ "aria-current": r.value }, i.value, { onClick: d }), {
        default: D(() => [
          A(y.$slots, "default", {}, () => [
            ie(J(y.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
}), Si = { "aria-label": "breadcrumb" }, wi = { class: "breadcrumb" }, Ci = /* @__PURE__ */ x({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(e) {
    const t = e, l = Go(), a = w(() => {
      const o = t.items || (l == null ? void 0 : l.items) || [];
      let n = !1;
      return o.map((r, i) => (typeof r == "string" && (r = { text: r }, i < o.length - 1 && (r.href = "#")), r.active && (n = !0), !r.active && !n && (r.active = i + 1 === o.length), r));
    });
    return (o, n) => (p(), P("nav", Si, [
      Z("ol", wi, [
        A(o.$slots, "prepend"),
        (p(!0), P(ve, null, he(a.value, (s, r) => (p(), M(on, le({ key: r }, s), {
          default: D(() => [
            ie(J(s.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        A(o.$slots, "default"),
        A(o.$slots, "append")
      ])
    ]));
  }
}), ki = /* @__PURE__ */ x({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.vertical), a = w(() => ({
      "btn-group": !l.value,
      [`btn-group-${t.size}`]: t.size !== "md",
      "btn-group-vertical": l.value
    }));
    return (o, n) => (p(), M(ne(o.tag), {
      class: z(a.value),
      role: "group",
      "aria-label": o.ariaLabel
    }, {
      default: D(() => [
        A(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), $i = ["role", "aria-label"], _i = /* @__PURE__ */ x({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: [String, Boolean], default: !1 },
    role: { default: "toolbar" }
  },
  setup(e) {
    const t = e, l = u(() => t.justify), a = w(() => ({
      "justify-content-between": l.value
    }));
    return (o, n) => (p(), P("div", {
      class: z([a.value, "btn-toolbar"]),
      role: o.role,
      "aria-label": o.ariaLabel
    }, [
      A(o.$slots, "default")
    ], 10, $i));
  }
}), Ti = ["src", "width", "height", "srcset", "sizes", "loading"], Vi = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', al = /* @__PURE__ */ x({
  __name: "BImg",
  props: {
    blank: { type: [String, Boolean], default: !1 },
    blankColor: { default: "transparent" },
    block: { type: [String, Boolean], default: !1 },
    center: { type: [String, Boolean], default: !1 },
    fluid: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    fluidGrow: { type: [String, Boolean], default: !1 },
    height: { default: void 0 },
    start: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    rounded: { type: [Boolean, String], default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: [String, Boolean], default: !1 },
    width: { default: void 0 }
  },
  setup(e) {
    const t = e, l = u(() => t.lazy), a = u(() => t.blank), o = u(() => t.block), n = u(() => t.center), s = u(() => t.fluid), r = u(() => t.fluidGrow), i = u(() => t.start), d = u(() => t.end), y = u(() => t.thumbnail), b = Be(N(() => t.height ?? NaN)), c = Be(N(() => t.width ?? NaN)), h = w(
      () => typeof t.srcset == "string" ? t.srcset.split(",").filter(($) => $).join(",") : Array.isArray(t.srcset) ? t.srcset.filter(($) => $).join(",") : void 0
    ), S = w(
      () => typeof t.sizes == "string" ? t.sizes.split(",").filter(($) => $).join(",") : Array.isArray(t.sizes) ? t.sizes.filter(($) => $).join(",") : void 0
    ), B = w(() => {
      const $ = Number.isNaN(c.value) ? void 0 : c.value, m = Number.isNaN(b.value) ? void 0 : b.value;
      if (a.value) {
        if ($ !== void 0 && m === void 0)
          return { height: $, width: $ };
        if ($ === void 0 && m !== void 0)
          return { height: m, width: m };
        if ($ === void 0 && m === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: $,
        height: m
      };
    }), F = w(
      () => T(B.value.width, B.value.height, t.blankColor)
    ), C = w(
      () => i.value ? "float-start" : d.value ? "float-end" : n.value ? "mx-auto" : void 0
    ), V = w(() => ({
      "img-thumbnail": y.value,
      "img-fluid": s.value || r.value,
      "w-100": r.value,
      rounded: t.rounded === "" || t.rounded === !0,
      [`rounded-${t.rounded}`]: typeof t.rounded == "string" && t.rounded !== "",
      [`${C.value}`]: C.value !== void 0,
      "d-block": o.value || n.value
    })), T = ($, m, k) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      Vi.replace("%{w}", String($)).replace("%{h}", String(m)).replace("%{f}", k)
    )}`;
    return ($, m) => (p(), P("img", {
      class: z(V.value),
      src: g(a) ? F.value : t.src,
      width: B.value.width || void 0,
      height: B.value.height || void 0,
      srcset: g(a) ? void 0 : h.value,
      sizes: g(a) ? void 0 : S.value,
      loading: g(l) ? "lazy" : "eager"
    }, null, 10, Ti));
  }
}), na = /* @__PURE__ */ x({
  __name: "BCardImg",
  props: {
    bottom: { type: [String, Boolean], default: !1 },
    top: { type: [String, Boolean], default: !1 },
    blank: { type: [String, Boolean] },
    blankColor: {},
    block: { type: [String, Boolean] },
    center: { type: [String, Boolean] },
    fluid: { type: [String, Boolean] },
    lazy: { type: [String, Boolean] },
    fluidGrow: { type: [String, Boolean] },
    height: {},
    start: { type: [String, Boolean] },
    end: { type: [String, Boolean] },
    rounded: { type: [Boolean, String] },
    sizes: {},
    src: {},
    srcset: {},
    thumbnail: { type: [String, Boolean] },
    width: {}
  },
  setup(e) {
    const t = e, l = u(() => t.bottom), a = u(() => t.end), o = u(() => t.start), n = u(() => t.top), s = w(
      () => n.value ? "card-img-top" : a.value ? "card-img-right" : l.value ? "card-img-bottom" : o.value ? "card-img-left" : "card-img"
    ), r = w(() => uo(t, ["bottom", "top", "end", "start"]));
    return (i, d) => (p(), M(al, le(r.value, { class: s.value }), null, 16, ["class"]));
  }
}), Ai = ["innerHTML"], nn = /* @__PURE__ */ x({
  __name: "BCardHeadFoot",
  props: {
    text: { default: void 0 },
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, l = qe(t), a = w(() => [
      l.value,
      {
        [`border-${t.borderVariant}`]: t.borderVariant !== null
      }
    ]);
    return (o, n) => (p(), M(ne(o.tag), {
      class: z(a.value)
    }, {
      default: D(() => [
        o.html ? (p(), P("div", {
          key: 0,
          innerHTML: o.html
        }, null, 8, Ai)) : A(o.$slots, "default", { key: 1 }, () => [
          ie(J(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), sn = /* @__PURE__ */ x({
  __name: "BCardHeader",
  props: {
    text: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (l, a) => (p(), M(nn, le({ class: "card-header" }, t), {
      default: D(() => [
        A(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), rn = /* @__PURE__ */ x({
  __name: "BCardTitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, l) => (p(), M(ne(t.tag), { class: "card-title" }, {
      default: D(() => [
        A(t.$slots, "default", {}, () => [
          ie(J(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), un = /* @__PURE__ */ x({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "body-secondary" }
  },
  setup(e) {
    const t = e, l = w(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null
    }));
    return (a, o) => (p(), M(ne(a.tag), {
      class: z(["card-subtitle mb-2", l.value])
    }, {
      default: D(() => [
        A(a.$slots, "default", {}, () => [
          ie(J(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), dn = /* @__PURE__ */ x({
  __name: "BCardBody",
  props: {
    tag: { default: "div" },
    overlay: { type: [String, Boolean], default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    text: { default: void 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, l = Oe(), a = u(() => t.overlay), o = qe(t), n = N(() => !Ae(l.title)), s = N(() => !Ae(l.subtitle)), r = w(() => [
      o.value,
      {
        "card-img-overlay": a.value
      }
    ]);
    return (i, d) => (p(), M(ne(i.tag), {
      class: z(["card-body", r.value])
    }, {
      default: D(() => [
        i.title || n.value ? (p(), M(rn, {
          key: 0,
          tag: i.titleTag
        }, {
          default: D(() => [
            A(i.$slots, "title", {}, () => [
              ie(J(i.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : K("", !0),
        i.subtitle || s.value ? (p(), M(un, {
          key: 1,
          tag: i.subtitleTag,
          "text-variant": i.subtitleTextVariant
        }, {
          default: D(() => [
            A(i.$slots, "subtitle", {}, () => [
              ie(J(i.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : K("", !0),
        A(i.$slots, "default", {}, () => [
          ie(J(i.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), cn = /* @__PURE__ */ x({
  __name: "BCardFooter",
  props: {
    text: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (l, a) => (p(), M(nn, le({ class: "card-footer" }, t), {
      default: D(() => [
        A(l.$slots, "default", {}, () => [
          ie(J(l.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), fn = /* @__PURE__ */ x({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyTextVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerVariant: { default: null },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerVariant: { default: null },
    headerTextVariant: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBottom: { type: [String, Boolean], default: !1 },
    imgEnd: { type: [String, Boolean], default: !1 },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { type: [String, Boolean], default: !1 },
    imgTop: { type: [String, Boolean], default: !1 },
    imgWidth: { default: void 0 },
    noBody: { type: [String, Boolean], default: !1 },
    overlay: { type: [String, Boolean], default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "body-secondary" },
    tag: { default: "div" },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    bodyText: { default: "" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, l = Oe(), a = u(() => t.imgBottom), o = u(() => t.imgEnd), n = u(() => t.imgStart), s = u(() => t.noBody), r = N(() => !Ae(l.header)), i = N(() => !Ae(l.footer)), d = qe(t), y = w(() => [
      d.value,
      {
        [`text-${t.align}`]: t.align !== void 0,
        [`border-${t.borderVariant}`]: t.borderVariant !== null,
        "flex-row": n.value,
        "flex-row-reverse": o.value
      }
    ]), b = w(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      start: t.imgStart,
      top: t.imgTop
    }));
    return (c, h) => (p(), M(ne(c.tag), {
      class: z(["card", y.value])
    }, {
      default: D(() => [
        g(a) ? K("", !0) : A(c.$slots, "img", { key: 0 }, () => [
          c.imgSrc ? (p(), M(na, Ve(le({ key: 0 }, b.value)), null, 16)) : K("", !0)
        ]),
        c.header || r.value || c.headerHtml ? (p(), M(sn, {
          key: 1,
          "bg-variant": c.headerBgVariant,
          variant: c.headerVariant,
          "border-variant": c.headerBorderVariant,
          html: c.headerHtml,
          tag: c.headerTag,
          "text-variant": c.headerTextVariant,
          class: z(c.headerClass)
        }, {
          default: D(() => [
            A(c.$slots, "header", {}, () => [
              ie(J(c.header), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "variant", "border-variant", "html", "tag", "text-variant", "class"])) : K("", !0),
        g(s) ? A(c.$slots, "default", { key: 3 }, () => [
          ie(J(c.bodyText), 1)
        ]) : (p(), M(dn, {
          key: 2,
          overlay: c.overlay,
          "bg-variant": c.bodyBgVariant,
          tag: c.bodyTag,
          "text-variant": c.bodyTextVariant,
          subtitle: c.subtitle,
          "subtitle-tag": c.subtitleTag,
          "subtitle-text-variant": c.subtitleTextVariant,
          title: c.title,
          "title-tag": c.titleTag,
          class: z(c.bodyClass)
        }, {
          default: D(() => [
            A(c.$slots, "default", {}, () => [
              ie(J(c.bodyText), 1)
            ])
          ]),
          _: 3
        }, 8, ["overlay", "bg-variant", "tag", "text-variant", "subtitle", "subtitle-tag", "subtitle-text-variant", "title", "title-tag", "class"])),
        c.footer || i.value || c.footerHtml ? (p(), M(cn, {
          key: 4,
          "bg-variant": c.footerBgVariant,
          "border-variant": c.footerBorderVariant,
          variant: c.footerVariant,
          html: c.footerHtml,
          tag: c.footerTag,
          "text-variant": c.footerTextVariant,
          class: z(c.footerClass)
        }, {
          default: D(() => [
            A(c.$slots, "footer", {}, () => [
              ie(J(c.footer), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "border-variant", "variant", "html", "tag", "text-variant", "class"])) : K("", !0),
        g(a) ? A(c.$slots, "img", { key: 5 }, () => [
          c.imgSrc ? (p(), M(na, Ve(le({ key: 0 }, b.value)), null, 16)) : K("", !0)
        ]) : K("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Oi = /* @__PURE__ */ x({
  __name: "BCardGroup",
  props: {
    columns: { type: [String, Boolean], default: !1 },
    deck: { type: [String, Boolean], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = u(() => t.columns), a = u(() => t.deck), o = w(
      () => a.value ? "card-deck" : l.value ? "card-columns" : "card-group"
    );
    return (n, s) => (p(), M(ne(n.tag), {
      class: z(o.value)
    }, {
      default: D(() => [
        A(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ei = /* @__PURE__ */ x({
  __name: "BCardText",
  props: {
    text: { default: void 0 },
    tag: { default: "p" }
  },
  setup(e) {
    return (t, l) => (p(), M(ne(t.tag), { class: "card-text" }, {
      default: D(() => [
        A(t.$slots, "default", {}, () => [
          ie(J(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Fi = ["id"], Pi = {
  key: 0,
  class: "carousel-indicators"
}, Ni = ["aria-current", "aria-label", "onClick"], Li = /* @__PURE__ */ Z("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Ii = { class: "visually-hidden" }, Hi = /* @__PURE__ */ Z("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), zi = { class: "visually-hidden" }, xi = /* @__PURE__ */ x({
  __name: "BCarousel",
  props: {
    ride: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [String, Boolean], default: !1 },
    rideReverse: { type: [String, Boolean], default: !1 },
    fade: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    background: { default: void 0 },
    modelValue: { default: 0 },
    controls: { type: [String, Boolean], default: !1 },
    indicators: { type: [String, Boolean], default: !1 },
    interval: { default: 5e3 },
    noTouch: { type: [String, Boolean], default: !1 },
    noWrap: { type: [String, Boolean], default: !1 },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" },
    keyboard: { type: [String, Boolean], default: !0 },
    touchThreshold: { default: 50 }
  },
  emits: ["slid", "slide", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Oe(), n = ke(() => a.id, "carousel"), s = Se(a, "modelValue", l, { passive: !0 }), r = u(() => a.keyboard), i = u(() => a.rideReverse), d = u(() => a.noHoverPause), y = u(() => a.fade), b = u(() => a.controls), c = u(() => a.indicators), h = u(() => a.noTouch), S = u(() => a.noWrap), B = Be(() => a.touchThreshold), F = Be(() => a.interval), C = R(!1), V = R(!1), T = R(!0), $ = R(null), m = R(null), k = R(s.value), f = Za(m), _ = w(
      () => Ql(a.ride) ? ia(a.ride) : a.ride
    ), L = w(
      () => `carousel-item carousel-item-${T.value ? "prev" : "next"} carousel-item-${T.value ? "end" : "start"}`
    ), v = w(
      () => `carousel-item active carousel-item-${T.value ? "start" : "end"}`
    ), { pause: I, resume: H } = Do(
      () => {
        i.value ? ae() : me();
      },
      F,
      { immediate: _.value === "carousel" }
    ), O = w(
      () => _.value === !0 && V.value === !0 || _.value === "carousel"
    ), q = w(() => Ca(o.default, "BCarouselSlide")), Q = w(() => ({ "carousel-fade": y.value })), X = (ee) => {
      var E;
      return new eo(ee, {
        componentId: n.value,
        cancelable: !1,
        target: m.value,
        direction: T.value ? "right" : "left",
        from: k.value,
        to: s.value,
        relatedTarget: ((E = $.value) == null ? void 0 : E.children[s.value]) ?? null
      });
    }, ue = (ee) => {
      if (C.value !== !0) {
        if (_.value === !0 && (V.value = !0), O.value === !0 && H(), T.value = !(ee < s.value), ee >= q.value.length) {
          if (S.value)
            return;
          s.value = 0;
          return;
        }
        if (ee < 0) {
          if (S.value)
            return;
          s.value = q.value.length - 1;
          return;
        }
        k.value = s.value, s.value = ee;
      }
    }, ae = () => {
      ue(s.value - 1);
    }, me = () => {
      ue(s.value + 1);
    }, te = (ee) => {
      r.value !== !1 && ee();
    }, de = () => {
      d.value || I();
    }, ye = () => {
      O.value && H();
    }, { lengthX: G } = Dr(m, {
      passive: !0,
      onSwipeStart() {
        h.value !== !0 && I();
      },
      onSwipeEnd() {
        if (h.value === !0)
          return;
        const ee = () => {
          O.value !== !1 && H();
        };
        if (G.value >= B.value) {
          me(), ee();
          return;
        }
        G.value <= -B.value && (ae(), ee());
      }
    }), oe = () => {
      l("slide", X("slide")), C.value = !0;
    }, fe = () => {
      l("slid", X("slid")), C.value = !1;
    }, W = (ee) => {
      s.value !== 0 && ee.classList.add("carousel-item");
    };
    return je(
      "ArrowLeft",
      () => {
        te(ae);
      },
      { target: m }
    ), je(
      "ArrowRight",
      () => {
        te(me);
      },
      { target: m }
    ), re(
      () => a.ride,
      () => {
        V.value = !1;
      }
    ), re(f, (ee) => {
      if (ee) {
        de();
        return;
      }
      ye();
    }), t({
      pause: I,
      resume: H,
      prev: ae,
      next: me
    }), Ue(co, {
      background: N(() => a.background),
      width: N(() => a.imgWidth),
      height: N(() => a.imgHeight)
    }), (ee, E) => (p(), P("div", {
      id: g(n),
      ref_key: "element",
      ref: m,
      class: z(["carousel slide pointer-event", Q.value])
    }, [
      g(c) ? (p(), P("div", Pi, [
        (p(!0), P(ve, null, he(q.value.length, (j, U) => (p(), P("button", {
          key: U,
          type: "button",
          "data-bs-target": "",
          class: z(U === g(s) ? "active" : ""),
          "aria-current": U === g(s) ? !0 : void 0,
          "aria-label": `${ee.indicatorsButtonLabel} ${U}`,
          onClick: (ce) => ue(U)
        }, null, 10, Ni))), 128))
      ])) : K("", !0),
      Z("div", {
        ref_key: "relatedTarget",
        ref: $,
        class: "carousel-inner"
      }, [
        be(Un, {
          "enter-from-class": L.value,
          "enter-active-class": L.value,
          "enter-to-class": L.value,
          "leave-from-class": v.value,
          "leave-active-class": v.value,
          "leave-to-class": v.value,
          onBeforeLeave: oe,
          onAfterLeave: fe,
          onAfterEnter: W
        }, {
          default: D(() => [
            (p(!0), P(ve, null, he(q.value, (j, U) => vt((p(), M(ne(j), {
              key: U,
              class: z({ active: U === g(s) && C.value === !1 })
            }, null, 8, ["class"])), [
              [ra, U === g(s)]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      g(b) ? (p(), P(ve, { key: 1 }, [
        Z("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: ae
        }, [
          Li,
          Z("span", Ii, J(ee.controlsPrevText), 1)
        ]),
        Z("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: me
        }, [
          Hi,
          Z("span", zi, J(ee.controlsNextText), 1)
        ])
      ], 64)) : K("", !0)
    ], 10, Fi));
  }
}), Ri = ["innerHTML"], Mi = { key: 1 }, Di = ["innerHTML"], ji = { key: 1 }, qi = /* @__PURE__ */ x({
  __name: "BCarouselSlide",
  props: {
    imgSrc: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgSrcset: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: [String, Boolean], default: !1 },
    imgBlankColor: { default: "transparent" },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, l = Oe(), a = Le(co, null), o = N(() => t.text || t.textHtml || !Ae(l.text)), n = N(() => t.caption || t.captionHtml || !Ae(l.caption)), s = N(() => o.value || n.value || !Ae(l.default)), r = w(() => ({
      background: `${t.background || (a == null ? void 0 : a.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), i = w(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (d, y) => (p(), P("div", {
      class: "carousel-item",
      style: xe(r.value)
    }, [
      A(d.$slots, "img", {}, () => {
        var b, c;
        return [
          be(al, {
            class: "d-block w-100",
            alt: d.imgAlt,
            srcset: d.imgSrcset,
            src: d.imgSrc,
            width: d.imgWidth || ((b = g(a)) == null ? void 0 : b.width.value),
            height: d.imgHeight || ((c = g(a)) == null ? void 0 : c.height.value),
            blank: d.imgBlank,
            "blank-color": d.imgBlankColor
          }, null, 8, ["alt", "srcset", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      s.value ? (p(), M(ne(d.contentTag), {
        key: 0,
        class: z(["carousel-caption", i.value])
      }, {
        default: D(() => [
          n.value ? (p(), M(ne(d.captionTag), { key: 0 }, {
            default: D(() => [
              A(d.$slots, "caption", {}, () => [
                d.captionHtml ? (p(), P("span", {
                  key: 0,
                  innerHTML: d.captionHtml
                }, null, 8, Ri)) : (p(), P("span", Mi, J(d.caption), 1))
              ])
            ]),
            _: 3
          })) : K("", !0),
          o.value ? (p(), M(ne(d.textTag), { key: 1 }, {
            default: D(() => [
              A(d.$slots, "text", {}, () => [
                d.textHtml ? (p(), P("span", {
                  key: 0,
                  innerHTML: d.textHtml
                }, null, 8, Di)) : (p(), P("span", ji, J(d.text), 1))
              ])
            ]),
            _: 3
          })) : K("", !0),
          A(d.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : K("", !0)
    ], 4));
  }
}), Vl = ua("", [], { type: [Boolean, String, Number], default: !1 }), Al = ua("offset", [""], { type: [String, Number], default: null }), Ol = ua("order", [""], { type: [String, Number], default: null }), Gi = x({
  name: "BCol",
  slots: Object,
  props: {
    col: { type: [Boolean, String], default: !1 },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Vl,
    offset: { type: [String, Number], default: null },
    ...Al,
    order: { type: [String, Number], default: null },
    ...Ol,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: Vl, propPrefix: "cols", classPrefix: "col" },
      { content: Al, propPrefix: "offset" },
      { content: Ol, propPrefix: "order" }
    ], l = u(() => e.col), a = w(
      () => t.flatMap((n) => io(e, n.content, n.propPrefix, n.classPrefix))
    );
    return {
      computedClasses: w(() => [
        a.value,
        {
          col: l.value || !a.value.some((n) => /^col-/.test(n)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
});
function Wi(e, t, l, a, o, n) {
  return p(), M(ne(e.tag), {
    class: z(e.computedClasses)
  }, {
    default: D(() => [
      A(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Lt = /* @__PURE__ */ ma(Gi, [["render", Wi]]), Ui = /* @__PURE__ */ x({
  __name: "BContainer",
  props: {
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    fluid: { type: [String, Boolean], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = Be(
      N(() => t.gutterX ?? NaN),
      { method: "parseInt" }
    ), a = Be(
      N(() => t.gutterY ?? NaN),
      { method: "parseInt" }
    ), o = w(
      () => Ql(t.fluid) ? ia(t.fluid) : t.fluid
    ), n = w(() => ({
      container: o.value === !1,
      "container-fluid": o.value === !0,
      [`container-${o.value}`]: typeof o.value == "string",
      [`gx-${l.value}`]: !Number.isNaN(l.value),
      [`gy-${a.value}`]: !Number.isNaN(a.value)
    }));
    return (s, r) => (p(), M(ne(s.tag), {
      class: z(n.value)
    }, {
      default: D(() => [
        A(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Xi = { class: "visually-hidden" }, Ki = ["aria-labelledby", "role"], vn = /* @__PURE__ */ x({
  __name: "BDropdown",
  props: {
    ariaLabel: { default: void 0 },
    id: { default: void 0 },
    menuClass: { default: void 0 },
    size: { default: "md" },
    splitClass: { default: void 0 },
    splitVariant: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    block: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: !1 },
    dropup: { type: [String, Boolean], default: !1 },
    dropend: { type: [String, Boolean], default: !1 },
    dropstart: { type: [String, Boolean], default: !1 },
    center: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    noFlip: { type: [String, Boolean], default: !1 },
    noShift: { type: [String, Boolean], default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    split: { type: [String, Boolean], default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    splitDisabled: { type: [String, Boolean], default: void 0 },
    noCaret: { type: [String, Boolean], default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    modelValue: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    splitTo: { default: void 0 },
    boundary: { default: "clippingAncestors" },
    container: { default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = ke(() => a.id, "dropdown"), n = Se(a, "modelValue", l, { passive: !0 }), s = u(n), r = u(() => a.block), i = u(() => a.dropup), d = u(() => a.dropend), y = u(() => a.isNav), b = u(() => a.dropstart), c = u(() => a.center), h = u(() => a.end), S = u(() => a.split), B = u(() => a.noCaret), F = u(() => a.noFlip), C = u(() => a.noShift), V = u(() => a.lazy), T = u(() => a.splitDisabled), $ = N(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), m = Be($), k = R(null), f = R(null), _ = R(null), L = R(null), v = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), I = w(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), H = N(() => S.value ? f.value : _.value);
    je(
      "Escape",
      () => {
        n.value = !s;
      },
      { target: H }
    ), je(
      "Escape",
      () => {
        n.value = !s;
      },
      { target: k }
    );
    const O = (W, ee) => {
      var j, U, ce, Y;
      if (W.preventDefault(), !s.value) {
        oe(), _e(() => O(W, ee));
        return;
      }
      const E = (j = k.value) == null ? void 0 : j.querySelectorAll(".dropdown-item:not(.disabled):not(:disabled)");
      if (E)
        if ((U = k.value) != null && U.contains(document.activeElement)) {
          const se = k.value.querySelector(".dropdown-item:focus"), $e = Array.prototype.indexOf.call(E, se) + ee;
          $e >= 0 && $e < (E == null ? void 0 : E.length) && ((ce = E[$e]) == null || ce.focus());
        } else
          (Y = E[ee === -1 ? E.length - 1 : 0]) == null || Y.focus();
    };
    je("ArrowUp", (W) => O(W, -1), { target: H }), je("ArrowDown", (W) => O(W, 1), { target: H }), je("ArrowUp", (W) => O(W, -1), { target: k }), je("ArrowDown", (W) => O(W, 1), { target: k });
    const q = w(
      () => ai({
        top: i.value,
        start: b.value,
        end: d.value,
        alignCenter: c.value,
        alignEnd: h.value
      })
    ), Q = w(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const W = typeof a.offset == "string" || typeof a.offset == "number" ? m.value : a.offset, ee = [$o(W)];
      return F.value === !1 && ee.push(
        Co({
          boundary: v.value,
          rootBoundary: I.value
        })
      ), C.value === !1 && ee.push(
        _o({
          boundary: v.value,
          rootBoundary: I.value
        })
      ), ee;
    }), { update: X, floatingStyles: ue } = Io(H, k, {
      placement: q,
      middleware: Q,
      strategy: Ee(N(a, "strategy")),
      whileElementsMounted: No
    }), ae = w(() => ({
      "d-grid": r.value,
      dropup: i.value,
      dropend: d.value,
      dropstart: b.value,
      "d-flex": r.value && S.value,
      "position-static": a.boundary !== "clippingAncestors" && !y.value
    })), me = w(() => [
      S.value ? a.splitClass : a.toggleClass,
      {
        "nav-link": y.value,
        "dropdown-toggle": !S.value,
        "dropdown-toggle-no-caret": B.value && !S.value,
        "w-100": S.value && r.value,
        show: S.value ? void 0 : s.value
      }
    ]), te = () => {
      fe();
    }, de = (W) => {
      S.value ? l("click", W) : te();
    };
    jo(
      k,
      () => {
        s.value && (a.autoClose === !0 || a.autoClose === "outside") && fe();
      },
      { ignore: [f, _] }
    );
    const ye = () => {
      s.value && (a.autoClose === !0 || a.autoClose === "inside") && fe();
    }, G = () => {
      n.value && fe();
    }, oe = () => {
      n.value || fe();
    }, fe = () => {
      var E;
      l("toggle");
      const W = s.value, ee = new Ft(W ? "hide" : "show");
      if (l(W ? "hide" : "show", ee), ee.defaultPrevented) {
        l(W ? "hide-prevented" : "show-prevented");
        return;
      }
      n.value = !W, l(W ? "hidden" : "shown"), (E = L.value) == null || E.dispatchEvent(new Event("forceHide"));
    };
    return re(s, X), t({
      close: G,
      open: oe,
      toggle: fe
    }), Ue(ho, {
      id: o,
      open: oe,
      close: G,
      toggle: fe,
      visible: s,
      isNav: y
    }), (W, ee) => (p(), P("div", {
      ref_key: "wrapper",
      ref: L,
      class: z([ae.value, "btn-group"])
    }, [
      be(ut, {
        id: g(o),
        ref_key: "splitButton",
        ref: _,
        variant: W.splitVariant || W.variant,
        size: W.size,
        class: z(me.value),
        disabled: g(T) || W.disabled,
        type: W.splitButtonType,
        "aria-label": W.ariaLabel,
        "aria-expanded": g(S) ? void 0 : g(s),
        "aria-haspopup": g(S) ? void 0 : "menu",
        href: g(S) ? W.splitHref : void 0,
        to: g(S) && W.splitTo ? W.splitTo : void 0,
        onClick: de
      }, {
        default: D(() => [
          A(W.$slots, "button-content", {}, () => [
            ie(J(W.text), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "variant", "size", "class", "disabled", "type", "aria-label", "aria-expanded", "aria-haspopup", "href", "to"]),
      g(S) ? (p(), M(ut, {
        key: 0,
        ref_key: "button",
        ref: f,
        variant: W.variant,
        size: W.size,
        disabled: W.disabled,
        class: z([[W.toggleClass, g(s) ? "show" : void 0], "dropdown-toggle-split dropdown-toggle"]),
        "aria-expanded": g(s),
        "aria-haspopup": "menu",
        onClick: te
      }, {
        default: D(() => [
          Z("span", Xi, [
            A(W.$slots, "toggle-text", {}, () => [
              ie(J(W.toggleText), 1)
            ])
          ])
        ]),
        _: 3
      }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : K("", !0),
      be(va, {
        tag: "Teleport",
        to: W.container,
        skip: !W.container
      }, {
        default: D(() => [
          !g(V) || g(s) ? vt((p(), P("ul", {
            key: 0,
            ref_key: "floating",
            ref: k,
            style: xe(g(ue)),
            class: z(["dropdown-menu show", W.menuClass]),
            "aria-labelledby": g(o),
            role: W.role,
            onClick: ye
          }, [
            A(W.$slots, "default", {
              hide: G,
              show: oe
            })
          ], 14, Ki)), [
            [ra, g(V) || g(s)]
          ]) : K("", !0)
        ]),
        _: 3
      }, 8, ["to", "skip"])
    ], 2));
  }
}), Ji = { role: "presentation" }, Yi = /* @__PURE__ */ x({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, l) => (p(), P("li", Ji, [
      (p(), M(ne(t.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), Zi = { role: "presentation" }, Qi = { class: "px-4 py-3" }, eu = /* @__PURE__ */ x({
  __name: "BDropdownForm",
  setup(e) {
    return (t, l) => (p(), P("li", Zi, [
      Z("form", Qi, [
        A(t.$slots, "default")
      ])
    ]));
  }
}), tu = { role: "presentation" }, au = ["id", "aria-describedby"], lu = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BDropdownGroup",
  props: {
    id: { default: void 0 },
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null }
  },
  setup(e) {
    const t = e, l = N(() => t.id ? `${t.id}_group_dd_header` : void 0), a = N(() => t.headerTag === "header" ? void 0 : "heading"), o = w(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== null
      }
    ]);
    return (n, s) => (p(), P("li", tu, [
      (p(), M(ne(n.headerTag), {
        id: l.value,
        class: z(["dropdown-header", o.value]),
        role: a.value
      }, {
        default: D(() => [
          A(n.$slots, "header", {}, () => [
            ie(J(n.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      Z("ul", le({
        id: n.id,
        role: "group",
        class: "list-unstyled"
      }, n.$attrs, {
        "aria-describedby": n.ariaDescribedby || l.value
      }), [
        A(n.$slots, "default")
      ], 16, au)
    ]));
  }
}), ou = { class: "dropdown-header" }, nu = /* @__PURE__ */ x({
  __name: "BDropdownHeader",
  setup(e) {
    return (t, l) => (p(), P("li", null, [
      Z("h6", ou, [
        A(t.$slots, "default")
      ])
    ]));
  }
}), su = { role: "presentation" }, ru = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BDropdownItem",
  props: {
    linkClass: { default: void 0 },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean] },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: {},
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean] }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = u(() => l.active), o = u(() => l.disabled), { computedLink: n, computedLinkProps: s } = ht(l), r = w(() => [
      l.linkClass,
      {
        active: a.value,
        disabled: o.value,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), i = N(() => n.value ? tt : l.href ? "a" : "button"), d = Le(ja, null), y = Le(ho, null), b = Le(qa, null), c = (h) => {
      var S, B, F;
      t("click", h), b !== null && ((S = b == null ? void 0 : b.autoClose) == null ? void 0 : S.value) === !0 && ((B = d == null ? void 0 : d.close) == null || B.call(d)), (F = y == null ? void 0 : y.close) == null || F.call(y);
    };
    return (h, S) => (p(), P("li", su, [
      (p(), M(ne(i.value), le({
        class: ["dropdown-item", r.value],
        disabled: g(o),
        "aria-disabled": g(o) ? !0 : null,
        "aria-current": g(a) ? !0 : null,
        href: i.value === "a" ? h.href : null,
        rel: h.rel,
        role: "menuitem",
        type: i.value === "button" ? "button" : null,
        target: h.target
      }, g(s), { onClick: c }), {
        default: D(() => [
          A(h.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "disabled", "aria-disabled", "aria-current", "href", "rel", "type", "target"]))
    ]));
  }
}), iu = { role: "presentation" }, uu = ["disabled"], du = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    activeClass: { default: "active" },
    disabled: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = u(() => l.active), o = u(() => l.disabled), n = w(() => [
      l.buttonClass,
      {
        [l.activeClass]: a.value,
        disabled: o.value,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), s = (r) => {
      t("click", r);
    };
    return (r, i) => (p(), P("li", iu, [
      Z("button", {
        role: "menu",
        type: "button",
        class: z(["dropdown-item", n.value]),
        disabled: g(o),
        onClick: s
      }, [
        A(r.$slots, "default")
      ], 10, uu)
    ]));
  }
}), cu = { role: "presentation" }, fu = { class: "px-4 py-1 mb-0 text-body-secondary" }, vu = /* @__PURE__ */ x({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, l) => (p(), P("li", cu, [
      Z("p", fu, [
        A(t.$slots, "default", {}, () => [
          ie(J(t.text), 1)
        ])
      ])
    ]));
  }
}), pu = ["id", "novalidate", "onSubmit"], pn = /* @__PURE__ */ x({
  __name: "BForm",
  props: {
    id: { default: void 0 },
    floating: { type: [String, Boolean], default: !1 },
    novalidate: { type: [String, Boolean], default: !1 },
    validated: { type: [String, Boolean], default: !1 }
  },
  emits: ["submit"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = R(null), n = u(() => a.floating), s = u(() => a.novalidate), r = u(() => a.validated), i = w(() => ({
      "form-floating": n.value,
      "was-validated": r.value
    })), d = (y) => {
      l("submit", y);
    };
    return t({
      element: o
    }), (y, b) => (p(), P("form", {
      id: y.id,
      ref_key: "element",
      ref: o,
      novalidate: g(s),
      class: z(i.value),
      onSubmit: Ha(d, ["prevent"])
    }, [
      A(y.$slots, "default")
    ], 42, pu));
  }
}), mu = { class: "form-floating" }, gu = ["for"], yu = /* @__PURE__ */ x({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: { default: void 0 },
    label: { default: void 0 },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (p(), P("div", mu, [
      A(t.$slots, "default", {}, () => [
        ie(J(t.text), 1)
      ]),
      Z("label", { for: t.labelFor }, [
        A(t.$slots, "label", {}, () => [
          ie(J(t.label), 1)
        ])
      ], 8, gu)
    ]));
  }
}), Va = /* @__PURE__ */ x({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [String, Boolean], default: !1 },
    text: { default: void 0 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    tag: { default: "div" },
    tooltip: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.forceShow), a = u(() => t.state), o = u(() => t.tooltip), n = N(() => l.value === !0 || a.value === !1), s = w(() => ({
      "d-block": n.value,
      "invalid-feedback": !o.value,
      "invalid-tooltip": o.value
    }));
    return (r, i) => (p(), M(ne(r.tag), {
      id: r.id,
      role: r.role,
      "aria-live": r.ariaLive,
      "aria-atomic": r.ariaLive ? !0 : void 0,
      class: z(s.value)
    }, {
      default: D(() => [
        A(r.$slots, "default", {}, () => [
          ie(J(r.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), Jt = /* @__PURE__ */ x({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, l) => (p(), M(ne(t.tag), { class: "row d-flex flex-wrap" }, {
      default: D(() => [
        A(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Aa = /* @__PURE__ */ x({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: [String, Boolean], default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "body-secondary" }
  },
  setup(e) {
    const t = e, l = u(() => t.inline), a = w(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null,
      "form-text": !l.value
    }));
    return (o, n) => (p(), M(ne(o.tag), {
      id: o.id,
      class: z(a.value)
    }, {
      default: D(() => [
        A(o.$slots, "default", {}, () => [
          ie(J(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Oa = /* @__PURE__ */ x({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [String, Boolean], default: !1 },
    text: { default: void 0 },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    tag: { default: "div" },
    tooltip: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.forceShow), a = u(() => t.state), o = u(() => t.tooltip), n = N(() => l.value === !0 || a.value === !0), s = w(() => ({
      "d-block": n.value,
      "valid-feedback": !o.value,
      "valid-tooltip": o.value
    }));
    return (r, i) => (p(), M(ne(r.tag), {
      id: r.id,
      role: r.role,
      "aria-live": r.ariaLive,
      "aria-atomic": r.ariaLive ? !0 : void 0,
      class: z(s.value)
    }, {
      default: D(() => [
        A(r.$slots, "default", {}, () => [
          ie(J(r.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), bu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"], hu = ["for"], mn = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledBy: { default: void 0 },
    form: { default: void 0 },
    indeterminate: { type: [String, Boolean], default: void 0 },
    name: { default: void 0 },
    id: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    plain: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    buttonGroup: { type: [String, Boolean], default: !1 },
    switch: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: null },
    inline: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: void 0 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: void 0 },
    value: { type: [Array, Set, Boolean, String, Object, Number, null], default: !0 },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Oe(), n = Se(a, "modelValue", l, { passive: !0 }), s = ke(() => a.id, "form-check"), r = u(() => a.indeterminate), i = u(() => a.autofocus), d = u(() => a.plain), y = u(() => a.button), b = u(() => a.buttonGroup), c = u(() => a.switch), h = u(() => a.disabled), S = u(() => a.inline), B = u(() => a.required), F = u(() => a.state), C = Le(yo, null), V = R(null), { focused: T } = Ne(V, {
      initialValue: i.value
    }), $ = N(() => !Ae(o.default));
    let m = !1;
    const k = w({
      get: () => {
        var O;
        return C !== null ? C.modelValue.value.map((q) => JSON.stringify(q)).includes(JSON.stringify(a.value)) : Array.isArray(n.value) ? (O = n.value) == null ? void 0 : O.map((q) => JSON.stringify(q)).includes(JSON.stringify(a.value)) : JSON.stringify(n.value) === JSON.stringify(a.value);
      },
      set: (O) => {
        const q = O ? a.value : a.uncheckedValue === void 0 && a.value !== !1 ? !1 : a.uncheckedValue;
        l("input", q), C === null && Array.isArray(n.value) ? O ? (n.value.push(a.value), a.uncheckedValue !== void 0 && (n.value = n.value.filter(
          (Q) => JSON.stringify(Q) !== JSON.stringify(a.uncheckedValue)
        ))) : (a.uncheckedValue !== void 0 && n.value.push(a.uncheckedValue), n.value = n.value.filter(
          (Q) => JSON.stringify(Q) !== JSON.stringify(a.value)
        )) : C !== null ? (m = !0, n.value = q, O === !1 ? C.remove(a.value) : C.set(a.value)) : n.value = q, _e(() => {
          l("change", q), m = !1;
        });
      }
    });
    re(n, (O) => {
      if (m) {
        m = !1;
        return;
      }
      C !== null && ((O === a.value || O === !0) && k.value !== !0 ? k.value = !0 : (O === a.uncheckedValue || O === !1) && k.value !== !1 && (k.value = !1));
    });
    const f = w(
      () => !!(a.name ?? (C == null ? void 0 : C.name.value)) && (B.value || (C == null ? void 0 : C.required.value))
    ), _ = N(() => b.value || ((C == null ? void 0 : C.buttons.value) ?? !1)), L = w(() => ({
      plain: d.value || ((C == null ? void 0 : C.plain.value) ?? !1),
      button: y.value || ((C == null ? void 0 : C.buttons.value) ?? !1),
      inline: S.value || ((C == null ? void 0 : C.inline.value) ?? !1),
      switch: c.value || ((C == null ? void 0 : C.switch.value) ?? !1),
      state: F.value || (C == null ? void 0 : C.state.value),
      size: a.size !== void 0 ? a.size : (C == null ? void 0 : C.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (C == null ? void 0 : C.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), v = Uo(L), I = Xo(L), H = Ko(L);
    return t({
      element: V,
      focus: () => {
        T.value = !0;
      },
      blur: () => {
        T.value = !1;
      }
    }), (O, q) => (p(), M(va, {
      skip: _.value,
      class: z(g(v))
    }, {
      default: D(() => {
        var Q, X, ue;
        return [
          vt(Z("input", le({ id: g(s) }, O.$attrs, {
            ref_key: "input",
            ref: V,
            "onUpdate:modelValue": q[0] || (q[0] = (ae) => k.value = ae),
            class: g(I),
            type: "checkbox",
            disabled: g(h) || ((Q = g(C)) == null ? void 0 : Q.disabled.value),
            required: f.value || void 0,
            name: O.name || ((X = g(C)) == null ? void 0 : X.name.value),
            form: O.form || ((ue = g(C)) == null ? void 0 : ue.form.value),
            "aria-label": O.ariaLabel,
            "aria-labelledby": O.ariaLabelledBy,
            "aria-required": f.value || void 0,
            value: O.value,
            indeterminate: g(r)
          }), null, 16, bu), [
            [Xn, k.value]
          ]),
          $.value || g(d) === !1 ? (p(), P("label", {
            key: 0,
            for: g(s),
            class: z(g(H))
          }, [
            A(O.$slots, "default")
          ], 10, hu)) : K("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Bu = ["id"], Su = ["innerHTML"], wu = ["textContent"], Cu = /* @__PURE__ */ x({
  __name: "BFormCheckboxGroup",
  props: {
    id: { default: void 0 },
    form: { default: void 0 },
    modelValue: { default: () => [] },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: "md" },
    stacked: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    switches: { type: [String, Boolean], default: !1 },
    textField: { default: "text" },
    validated: { type: [String, Boolean], default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l), n = ke(() => a.id, "checkbox"), s = ke(() => a.name, "checkbox"), r = u(() => a.autofocus), i = u(() => a.buttons), d = u(() => a.disabled), y = u(() => a.plain), b = u(() => a.required), c = u(() => a.stacked), h = u(() => a.state), S = u(() => a.switches), B = u(() => a.validated), F = R(null), { focused: C } = Ne(F, {
      initialValue: r.value
    });
    Ue(yo, {
      set: (k) => {
        let f = [...o.value];
        f = f.filter((_) => JSON.stringify(_) !== JSON.stringify(k)), f.push(k), l("input", f), o.value = f, _e(() => {
          l("change", f);
        });
      },
      remove: (k) => {
        let f = [...o.value];
        f = f.filter((_) => JSON.stringify(_) !== JSON.stringify(k)), l("input", f), o.value = f, _e(() => {
          l("change", f);
        });
      },
      modelValue: N(() => o.value),
      switch: S,
      buttonVariant: N(() => a.buttonVariant),
      form: N(() => a.form),
      name: s,
      state: h,
      plain: y,
      size: N(() => a.size),
      inline: N(() => !c.value),
      required: b,
      buttons: i,
      disabled: d
    });
    const V = w(
      () => a.options.map(
        (k, f) => typeof k == "string" || typeof k == "number" ? {
          props: {
            value: k,
            disabled: d.value
          },
          text: k.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${f}`)
        } : {
          props: {
            value: k[a.valueField],
            disabled: k[a.disabledField],
            ...k.props ? k.props : {}
          },
          text: k[a.textField],
          html: k[a.htmlField],
          self: Symbol(`checkboxGroupOptionItem${f}`)
        }
      )
    ), T = w(() => ({
      required: b.value,
      ariaInvalid: a.ariaInvalid,
      state: h.value,
      validated: B.value,
      buttons: i.value,
      stacked: c.value,
      size: a.size
    })), $ = Jo(T), m = Yo(T);
    return t({
      focus: () => {
        C.value = !0;
      },
      blur: () => {
        C.value = !1;
      }
    }), (k, f) => (p(), P("div", le(g($), {
      id: g(n),
      ref_key: "element",
      ref: F,
      role: "group",
      class: [g(m), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      A(k.$slots, "first"),
      (p(!0), P(ve, null, he(V.value, (_) => (p(), M(mn, le({
        key: _.self
      }, _.props), {
        default: D(() => [
          _.html ? (p(), P("span", {
            key: 0,
            innerHTML: _.html
          }, null, 8, Su)) : (p(), P("span", {
            key: 1,
            textContent: J(_.text)
          }, null, 8, wu))
        ]),
        _: 2
      }, 1040))), 128)),
      A(k.$slots, "default")
    ], 16, Bu));
  }
}), ku = ["for"], $u = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-required", "directory", "webkitdirectory"], _u = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BFormFile",
  props: {
    accept: { default: "" },
    autofocus: { type: [String, Boolean], default: !1 },
    capture: { type: [Boolean, String], default: !1 },
    directory: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    multiple: { type: [String, Boolean], default: !1 },
    name: { default: void 0 },
    noDrop: { type: [String, Boolean], default: !1 },
    noTraverse: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    modelValue: { default: null },
    label: { default: "" },
    labelClass: { default: void 0 }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Oe(), n = Se(a, "modelValue", l), s = ke(() => a.id), r = u(() => a.autofocus), i = u(() => a.directory), d = u(() => a.disabled), y = u(() => a.multiple), b = u(() => a.noDrop);
    u(() => a.noTraverse);
    const c = u(() => a.required), h = u(() => a.state), S = Bt(h), B = R(null), { focused: F } = Ne(B, { initialValue: r.value }), C = N(() => !Ae(o.label)), V = N(
      () => typeof a.accept == "string" ? a.accept : a.accept.join(",")
    ), T = w(
      () => a.capture === "user" || a.capture === "environment" ? a.capture : ia(a.capture)
    ), $ = w(() => [
      S.value,
      {
        [`form-control-${a.size}`]: a.size !== void 0
      }
    ]), m = (_) => {
      var v, I;
      const L = ((v = B.value) == null ? void 0 : v.files) === null || ((I = B.value) == null ? void 0 : I.files) === void 0 ? null : [...B.value.files];
      n.value = L === null ? null : y.value === !0 ? L : L[0], l("change", _);
    }, k = (_) => {
      b.value === !0 && _.preventDefault();
    }, f = () => {
      n.value = null;
    };
    return re(n, (_) => {
      _ === null && B.value !== null && (B.value.value = "");
    }), t({
      element: B,
      focus: () => {
        F.value = !0;
      },
      blur: () => {
        F.value = !1;
      },
      reset: f
    }), (_, L) => (p(), P(ve, null, [
      C.value || _.label ? (p(), P("label", {
        key: 0,
        for: g(s),
        class: z(["form-label", _.labelClass])
      }, [
        A(_.$slots, "label", {}, () => [
          ie(J(_.label), 1)
        ])
      ], 10, ku)) : K("", !0),
      Z("input", le({ id: g(s) }, _.$attrs, {
        ref_key: "input",
        ref: B,
        type: "file",
        class: ["form-control", $.value],
        form: _.form,
        name: _.name,
        multiple: g(y),
        disabled: g(d),
        capture: T.value,
        accept: V.value || void 0,
        required: g(c) || void 0,
        "aria-required": g(c) || void 0,
        directory: g(i),
        webkitdirectory: g(i),
        onChange: m,
        onDrop: k
      }), null, 16, $u)
    ], 64));
  }
}), gn = ["input", "select", "textarea"], Tu = gn.map((e) => `${e}:not([disabled])`).join(), Vu = [...gn, "a", "button", "label"], Au = "label", Ou = "invalid-feedback", Eu = "valid-feedback", Fu = "description", Pu = "default", Nu = x({
  components: { BCol: Lt, BFormInvalidFeedback: Va, BFormRow: Jt, BFormText: Aa, BFormValidFeedback: Oa },
  props: {
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e, { attrs: t }) {
    const l = u(() => e.disabled), a = u(() => e.labelSrOnly), o = u(() => e.state), n = u(() => e.tooltip), s = u(() => e.validated), r = u(() => e.floating), i = null, d = ["xs", "sm", "md", "lg", "xl"], y = (m, k) => d.reduce((f, _) => {
      const L = vl(_ === "xs" ? "" : _, `${k}Align`), v = m[L] || null;
      return v && (_ === "xs" ? f.push(`text-${v}`) : f.push(`text-${_}-${v}`)), f;
    }, []), b = (m, k) => d.reduce((f, _) => {
      const L = vl(_ === "xs" ? "" : _, `${k}Cols`);
      let v = m[L];
      return v = v === "" ? !0 : v || !1, typeof v != "boolean" && v !== "auto" && (v = Os(v, 0), v = v > 0 ? v : !1), v && (_ === "xs" ? f[typeof v == "boolean" ? "col" : "cols"] = v : f[_ || (typeof v == "boolean" ? "col" : "cols")] = v), f;
    }, {}), c = R(), h = (m, k = null) => {
      if (Ra && e.labelFor) {
        const f = so(`#${us(e.labelFor)}`, c);
        if (f) {
          const _ = "aria-describedby", L = (m || "").split(Xt), v = (k || "").split(Xt), I = (Ma(f, _) || "").split(Xt).filter((H) => !v.includes(H)).concat(L).filter((H, O, q) => q.indexOf(H) === O).filter((H) => H).join(" ").trim();
          I ? $s(f, _, I) : _s(f, _);
        }
      }
    }, S = w(() => b(e, "content")), B = w(() => y(e, "label")), F = w(() => b(e, "label")), C = w(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(S.value).length > 0 || Object.keys(F.value).length > 0
      )
    ), V = Bt(o), T = w(
      () => da(t.ariaInvalid, o.value)
    );
    return re(
      () => i,
      (m, k) => {
        m !== k && h(m, k);
      }
    ), Ze(() => {
      _e(() => {
        h(i);
      });
    }), {
      disabledBoolean: l,
      labelSrOnlyBoolean: a,
      stateBoolean: o,
      tooltipBoolean: n,
      validatedBoolean: s,
      floatingBoolean: r,
      ariaDescribedby: i,
      computedAriaInvalid: T,
      contentColProps: S,
      isHorizontal: C,
      labelAlignClasses: B,
      labelColProps: F,
      onLegendClick: (m) => {
        if (e.labelFor)
          return;
        const { target: k } = m, f = k ? k.tagName : "";
        if (Vu.indexOf(f) !== -1)
          return;
        const _ = Cs(Tu, c).filter(ws);
        _.length === 1 && Bs(_[0]);
      },
      stateClass: V
    };
  },
  render() {
    const e = this.$props, t = this.$slots, l = ke(), a = !e.labelFor;
    let o = null;
    const n = at(Au, {}, t) || e.label, s = n ? mt("_BV_label_") : null;
    if (n || this.isHorizontal) {
      const $ = a ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        n && (o = ge(
          $,
          {
            class: "visually-hidden",
            id: s,
            for: e.labelFor || null
          },
          n
        )), this.isHorizontal ? o = ge(Lt, this.labelColProps, { default: () => o }) : o = ge("div", {}, [o]);
      else {
        const m = {
          onClick: a ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? $ : null,
          id: s,
          for: e.labelFor || null,
          tabIndex: a ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": a,
              "col-form-label": this.isHorizontal || a,
              "pt-0": !this.isHorizontal && a,
              "d-block": !this.isHorizontal && !a,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? o = ge(Lt, m, { default: () => n }) : o = ge($, m, n);
      }
    }
    let r = null;
    const i = at(Ou, {}, t) || this.invalidFeedback, d = i ? mt("_BV_feedback_invalid_") : void 0;
    i && (r = ge(
      Va,
      {
        ariaLive: e.feedbackAriaLive,
        id: d,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => i }
    ));
    let y = null;
    const b = at(Eu, {}, t) || this.validFeedback, c = b ? mt("_BV_feedback_valid_") : void 0;
    b && (y = ge(
      Oa,
      {
        ariaLive: e.feedbackAriaLive,
        id: c,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => b }
      // validFeedbackContent
    ));
    let h = null;
    const S = at(Fu, {}, t) || this.description, B = S ? mt("_BV_description_") : void 0;
    S && (h = ge(
      Aa,
      {
        id: B
      },
      { default: () => S }
    ));
    const F = this.ariaDescribedby = [
      B,
      this.stateBoolean === !1 ? d : null,
      this.stateBoolean === !0 ? c : null
    ].filter(($) => $).join(" ") || null, C = [
      at(Pu, { ariaDescribedby: F, descriptionId: B, id: l, labelId: s }, t) || "",
      r,
      y,
      h
    ];
    !this.isHorizontal && this.floatingBoolean && C.push(o);
    let V = ge(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      C
    );
    this.isHorizontal && (V = ge(Lt, { ref: "content", ...this.contentColProps }, { default: () => C }));
    const T = {
      class: [
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: ke(() => e.id).value,
      disabled: a ? this.disabledBoolean : null,
      role: a ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": a && this.isHorizontal ? s : null
    };
    return this.isHorizontal && !a ? ge(Jt, T, { default: () => [o, V] }) : ge(
      a ? "fieldset" : "div",
      T,
      this.isHorizontal && a ? [ge(Jt, null, { default: () => [o, V] })] : this.isHorizontal || !this.floatingBoolean ? [o, V] : [V]
    );
  }
}), Lu = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"], Iu = /* @__PURE__ */ x({
  __name: "BFormInput",
  props: {
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    form: { default: void 0 },
    debounce: { default: 0 },
    debounceMaxWait: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: [String, Boolean], default: !1 },
    lazyFormatter: { type: [String, Boolean], default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: [String, Boolean], default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: [String, Boolean], default: !1 },
    readonly: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    trim: { type: [String, Boolean], default: !1 }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { expose: t, emit: l }) {
    const a = e, { input: o, computedId: n, computedAriaInvalid: s, onInput: r, onChange: i, onBlur: d, focus: y, blur: b } = Zo(a, l), c = u(() => a.disabled), h = u(() => a.required), S = u(() => a.readonly), B = u(() => a.plaintext), F = u(() => a.state), C = Bt(F), V = R(!1), T = w(() => {
      const $ = a.type === "range", m = a.type === "color";
      return [
        C.value,
        {
          "form-control-highlighted": V.value,
          "form-range": $,
          "form-control": m || !a.plaintext && !$,
          "form-control-color": m,
          "form-control-plaintext": a.plaintext && !$ && !m,
          [`form-control-${a.size}`]: !!a.size
        }
      ];
    });
    return t({
      element: o,
      focus: y,
      blur: b
    }), ($, m) => (p(), P("input", {
      id: g(n),
      ref_key: "input",
      ref: o,
      class: z(T.value),
      name: $.name || void 0,
      form: $.form || void 0,
      type: $.type,
      disabled: g(c),
      placeholder: $.placeholder,
      required: g(h) || void 0,
      autocomplete: $.autocomplete || void 0,
      readonly: g(S) || g(B),
      min: $.min,
      max: $.max,
      step: $.step,
      list: $.type !== "password" ? $.list : void 0,
      "aria-required": g(h) || void 0,
      "aria-invalid": g(s),
      onInput: m[0] || (m[0] = (k) => g(r)(k)),
      onChange: m[1] || (m[1] = (k) => g(i)(k)),
      onBlur: m[2] || (m[2] = (k) => g(d)(k))
    }, null, 42, Lu));
  }
}), Hu = ["id", "checked", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], zu = ["for"], yn = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BFormRadio",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    size: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    plain: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    buttonGroup: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: null },
    inline: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    value: { type: [Boolean, String, Array, Object, Number, null], default: !0 }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Oe(), n = Se(a, "modelValue", l, { passive: !0 }), s = ke(() => a.id, "form-check"), r = u(() => a.autofocus), i = u(() => a.plain), d = u(() => a.button), y = u(() => a.buttonGroup), b = u(() => a.disabled), c = u(() => a.inline), h = u(() => a.required), S = u(() => a.state), B = Le(bo, null), F = R(null), { focused: C } = Ne(F, {
      initialValue: r.value
    }), V = N(() => !Ae(o.default)), T = w({
      get: () => B !== null ? JSON.stringify(B.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(n.value) === JSON.stringify(a.value),
      set: (v) => {
        const I = v || v === "" || v === 0 || JSON.stringify(v) === JSON.stringify(a.value) ? a.value : !1;
        l("input", I), n.value = I, _e(() => {
          l("change", I);
        }), B !== null && B.set(a.value);
      }
    });
    re(n, (v) => {
      B === null || v === !1 || B.set(a.value);
    });
    const $ = w(
      () => !!(a.name ?? (B == null ? void 0 : B.name.value)) && (h.value || (B == null ? void 0 : B.required.value))
    ), m = N(() => y.value || ((B == null ? void 0 : B.buttons.value) ?? !1)), k = w(() => ({
      plain: i.value || ((B == null ? void 0 : B.plain.value) ?? !1),
      button: d.value || ((B == null ? void 0 : B.buttons.value) ?? !1),
      inline: c.value || ((B == null ? void 0 : B.inline.value) ?? !1),
      state: S.value || (B == null ? void 0 : B.state.value),
      size: a.size !== void 0 ? a.size : (B == null ? void 0 : B.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (B == null ? void 0 : B.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), f = Uo(k), _ = Xo(k), L = Ko(k);
    return t({
      element: F,
      focus: () => {
        C.value = !0;
      },
      blur: () => {
        C.value = !1;
      }
    }), (v, I) => (p(), M(va, {
      skip: m.value,
      class: z(g(f))
    }, {
      default: D(() => {
        var H, O, q;
        return [
          vt(Z("input", le({ id: g(s) }, v.$attrs, {
            ref_key: "input",
            ref: F,
            "onUpdate:modelValue": I[0] || (I[0] = (Q) => T.value = Q),
            checked: T.value,
            class: g(_),
            type: "radio",
            disabled: g(b) || ((H = g(B)) == null ? void 0 : H.disabled.value),
            required: $.value || void 0,
            name: v.name || ((O = g(B)) == null ? void 0 : O.name.value),
            form: v.form || ((q = g(B)) == null ? void 0 : q.form.value),
            "aria-label": v.ariaLabel,
            "aria-labelledby": v.ariaLabelledby,
            value: v.value,
            "aria-required": $.value || void 0
          }), null, 16, Hu), [
            [Kn, T.value]
          ]),
          V.value || g(i) === !1 ? (p(), P("label", {
            key: 0,
            for: g(s),
            class: z(g(L))
          }, [
            A(v.$slots, "default")
          ], 10, zu)) : K("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), xu = ["id"], Ru = ["innerHTML"], Mu = ["textContent"], Du = /* @__PURE__ */ x({
  __name: "BFormRadioGroup",
  props: {
    size: { default: "md" },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    modelValue: { type: [String, Boolean, Array, Object, Number, null], default: null },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    stacked: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: [String, Boolean], default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l), n = ke(() => a.id, "radio"), s = ke(() => a.name, "checkbox"), r = u(() => a.autofocus), i = u(() => a.buttons), d = u(() => a.disabled), y = u(() => a.plain), b = u(() => a.required), c = u(() => a.stacked), h = u(() => a.state), S = u(() => a.validated), B = R(null), { focused: F } = Ne(B, {
      initialValue: r.value
    });
    Ue(bo, {
      set: (m) => {
        l("input", m), o.value = m, _e(() => {
          l("change", m);
        });
      },
      modelValue: N(() => o.value),
      buttonVariant: N(() => a.buttonVariant),
      form: N(() => a.form),
      name: s,
      buttons: i,
      state: h,
      plain: y,
      size: N(() => a.size),
      inline: N(() => !c.value),
      required: b,
      disabled: d
    });
    const C = w(
      () => a.options.map(
        (m, k) => typeof m == "string" || typeof m == "number" ? {
          props: {
            value: m,
            disabled: d.value
          },
          text: m.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${k}`)
        } : {
          props: {
            value: m[a.valueField],
            disabled: m[a.disabledField],
            ...m.props ? m.props : {}
          },
          text: m[a.textField],
          html: m[a.htmlField],
          self: Symbol(`radioGroupOptionItem${k}`)
        }
      )
    ), V = w(() => ({
      required: b.value,
      ariaInvalid: a.ariaInvalid,
      state: h.value,
      validated: S.value,
      buttons: i.value,
      stacked: c.value,
      size: a.size
    })), T = Jo(V), $ = Yo(V);
    return t({
      focus: () => {
        F.value = !0;
      },
      blur: () => {
        F.value = !1;
      }
    }), (m, k) => (p(), P("div", le(g(T), {
      id: g(n),
      ref_key: "element",
      ref: B,
      role: "radiogroup",
      class: [g($), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      A(m.$slots, "first"),
      (p(!0), P(ve, null, he(C.value, (f) => (p(), M(yn, le({
        key: f.self
      }, f.props), {
        default: D(() => [
          f.html ? (p(), P("span", {
            key: 0,
            innerHTML: f.html
          }, null, 8, Ru)) : (p(), P("span", {
            key: 1,
            textContent: J(f.text)
          }, null, 8, Mu))
        ]),
        _: 2
      }, 1040))), 128)),
      A(m.$slots, "default")
    ], 16, xu));
  }
}), ju = ["value", "disabled"], ll = /* @__PURE__ */ x({
  __name: "BFormSelectOption",
  props: {
    value: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.disabled);
    return (a, o) => (p(), P("option", {
      value: a.value,
      disabled: g(l)
    }, [
      A(a.$slots, "default")
    ], 8, ju));
  }
}), qu = ["label"], bn = /* @__PURE__ */ x({
  __name: "BFormSelectOptionGroup",
  props: {
    label: { default: void 0 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, l = w(
      () => Qa(t.options, "BFormSelectOptionGroup", t)
    );
    return (a, o) => (p(), P("optgroup", { label: a.label }, [
      A(a.$slots, "first"),
      (p(!0), P(ve, null, he(l.value, (n, s) => (p(), M(ll, le({
        key: s,
        value: n.value,
        disabled: n.disabled
      }, a.$attrs, {
        innerHTML: n.html || n.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      A(a.$slots, "default")
    ], 8, qu));
  }
}), Gu = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], Wu = /* @__PURE__ */ x({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    multiple: { type: [String, Boolean], default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [String, Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l), n = ke(() => a.id, "input"), s = u(() => a.autofocus), r = u(() => a.disabled), i = u(() => a.multiple), d = u(() => a.plain), y = u(() => a.required), b = u(() => a.state), c = Be(() => a.selectSize), h = Bt(b), S = R(), { focused: B } = Ne(S, {
      initialValue: s.value
    }), F = w(() => [
      h.value,
      {
        "form-control": d.value,
        [`form-control-${a.size}`]: a.size !== "md" && d.value,
        "form-select": !d.value,
        [`form-select-${a.size}`]: a.size !== "md" && !d.value
      }
    ]), C = N(
      () => c.value || d.value ? c.value : void 0
    ), V = w(
      () => da(a.ariaInvalid, b.value)
    ), T = w(() => Qa(a.options, "BFormSelect", a)), $ = w({
      get: () => o.value,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set: (m) => {
        l("input", m), o.value = m, _e(() => {
          l("change", m);
        });
      }
    });
    return t({
      element: S,
      focus: () => {
        B.value = !0;
      },
      blur: () => {
        B.value = !1;
      }
    }), (m, k) => vt((p(), P("select", {
      id: g(n),
      ref_key: "input",
      ref: S,
      "onUpdate:modelValue": k[0] || (k[0] = (f) => $.value = f),
      class: z(F.value),
      name: m.name,
      form: m.form || void 0,
      multiple: g(i) || void 0,
      size: C.value,
      disabled: g(r),
      required: g(y) || void 0,
      "aria-required": g(y) || void 0,
      "aria-invalid": V.value
    }, [
      A(m.$slots, "first"),
      (p(!0), P(ve, null, he(T.value, (f, _) => (p(), P(ve, { key: _ }, [
        Array.isArray(f.options) ? (p(), M(bn, {
          key: 0,
          label: f.label,
          options: f.options
        }, null, 8, ["label", "options"])) : (p(), M(ll, {
          key: 1,
          value: f.value,
          disabled: f.disabled,
          innerHTML: f.html || f.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 128)),
      A(m.$slots, "default")
    ], 10, Gu)), [
      [Jn, $.value]
    ]);
  }
}), El = [
  "ar",
  "az",
  "ckb",
  "fa",
  "he",
  "ks",
  "lrc",
  "mzn",
  "ps",
  "sd",
  "te",
  "ug",
  "ur",
  "yi"
].map((e) => e.toLowerCase()), Uu = (e) => {
  const t = Yt(e).toLowerCase().replace(ls, "").split("-"), l = t.slice(0, 2).join("-"), [a] = t;
  return El.includes(l) || El.includes(a);
}, Xu = (e) => ms ? Sa(e) ? e : { capture: !!e || !1 } : !!(Sa(e) ? e.capture : e), Ku = (e, t, l, a) => {
  e && e.addEventListener && e.addEventListener(t, l, Xu(a));
}, Ju = (e, t, l, a) => {
  e && e.removeEventListener && e.removeEventListener(t, l, a);
}, Fl = (e, t) => {
  (e ? Ku : Ju)(...t);
}, Wt = (e, { preventDefault: t = !0, propagation: l = !0, immediatePropagation: a = !1 } = {}) => {
  t && e.preventDefault(), l && e.stopPropagation(), a && e.stopImmediatePropagation();
}, Ea = "ArrowDown", hn = "End", Bn = "Home", Sn = "PageDown", wn = "PageUp", Fa = "ArrowUp", Pl = 1, Nl = 100, Ll = 1, Il = 500, Hl = 100, zl = 10, xl = 4, Rl = [Fa, Ea, Bn, hn, wn, Sn], Yu = x({
  props: {
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: void 0 },
    labelIncrement: { type: String, default: "Increment" },
    labelDecrement: { type: String, default: "Decrement" },
    modelValue: { type: Number, default: null },
    // V-model prop
    name: { type: String, default: "BFormSpinbutton" },
    disabled: { type: [Boolean, String], default: !1 },
    placeholder: { type: String, default: void 0 },
    locale: { type: String, default: "locale" },
    form: { type: String, default: void 0 },
    inline: { type: Boolean, default: !1 },
    size: { type: String, default: void 0 },
    formatterFn: {
      type: Function,
      default: void 0
    },
    readonly: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 },
    repeatDelay: {
      type: [String, Number],
      default: Il
    },
    repeatInterval: {
      type: [String, Number],
      default: Hl
    },
    repeatStepMultiplier: {
      type: [String, Number],
      default: xl
    },
    repeatThreshold: {
      type: [String, Number],
      default: zl
    },
    required: { type: [Boolean, String], default: !1 },
    step: { type: [String, Number], default: Ll },
    min: { type: [String, Number], default: Pl },
    max: { type: [String, Number], default: Nl },
    wrap: { type: Boolean, default: !1 },
    state: { type: [Boolean, String], default: null }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const l = Se(e, "modelValue", t), a = R(!1), o = w(() => 1), n = () => {
      t("change", r.value);
    }, s = R(null), r = w({
      get: () => l.value === null ? s.value : l.value,
      set: (G) => {
        l.value === null ? s.value = G : l.value = G;
      }
    });
    let i, d, y = !1;
    const b = w(() => Kt(e.step, Ll)), c = w(() => Kt(e.min, Pl)), h = w(() => {
      const G = Kt(e.max, Nl), oe = b.value, fe = c.value;
      return Math.floor((G - fe) / oe) * oe + fe;
    }), S = w(() => {
      const G = gt(e.repeatDelay, 0);
      return G > 0 ? G : Il;
    }), B = w(() => {
      const G = gt(e.repeatInterval, 0);
      return G > 0 ? G : Hl;
    }), F = w(
      () => Math.max(gt(e.repeatThreshold, zl), 1)
    ), C = w(
      () => Math.max(gt(e.repeatStepMultiplier, xl), 1)
    ), V = w(() => {
      const G = b.value;
      return Math.floor(G) === G ? 0 : (G.toString().split(".")[1] || "").length;
    }), T = w(() => Math.pow(10, V.value || 0)), $ = w(() => {
      const { value: G } = r;
      return G === null ? "" : G.toFixed(V.value);
    }), m = w(() => {
      const G = [e.locale];
      return new Intl.NumberFormat(G).resolvedOptions().locale;
    }), k = w(
      () => (
        //todo
        Uu(m.value)
      )
    ), f = () => {
      const G = V.value;
      return new Intl.NumberFormat(m.value, {
        style: "decimal",
        useGrouping: !1,
        minimumIntegerDigits: 1,
        minimumFractionDigits: G,
        maximumFractionDigits: G,
        notation: "standard"
      }).format;
    }, _ = w(() => e.formatterFn ?? f()), L = w(() => ({
      role: "group",
      lang: m.value,
      tabindex: e.disabled ? null : "-1",
      title: e.ariaLabel
    })), v = w(() => l.value !== null || s.value !== null), I = w(() => ({
      dir: k.value,
      spinId: o.value,
      tabindex: e.disabled ? null : "0",
      role: "spinbutton",
      "aria-live": "off",
      "aria-label": e.ariaLabel || null,
      "aria-controls": e.ariaControls || null,
      "aria-invalid": e.state === !1 || !v.value && e.required ? !0 : null,
      "aria-required": e.required ? !0 : null,
      "aria-valuemin": c.value,
      "aria-valuemax": h.value,
      "aria-valuenow": r.value !== null ? r.value : null,
      "aria-valuetext": r.value !== null ? _.value(r.value) : null
    })), H = (G) => {
      let { value: oe } = r;
      if (!e.disabled && oe !== null) {
        const fe = b.value * G, W = c.value, ee = h.value, E = T.value, { wrap: j } = e;
        oe = Math.round((oe - W) / fe) * fe + W + fe, oe = Math.round(oe * E) / E, r.value = oe > ee ? j ? W : ee : oe < W ? j ? ee : W : oe;
      }
    }, O = (G = 1) => {
      r.value === null ? r.value = c.value : H(1 * G);
    }, q = (G = 1) => {
      r.value === null ? r.value = e.wrap ? h.value : c.value : H(-1 * G);
    }, Q = (G) => {
      const { code: oe, altKey: fe, ctrlKey: W, metaKey: ee } = G;
      if (!(e.disabled || e.readonly || fe || W || ee) && Rl.includes(oe)) {
        if (Wt(G, { propagation: !1 }), y)
          return;
        de(), [Fa, Ea].includes(oe) ? (y = !0, oe === Fa ? ue(G, O) : oe === Ea && ue(G, q)) : oe === wn ? O(C.value) : oe === Sn ? q(C.value) : oe === Bn ? r.value = c.value : oe === hn && (r.value = h.value);
      }
    }, X = (G) => {
      const { code: oe, altKey: fe, ctrlKey: W, metaKey: ee } = G;
      e.disabled || e.readonly || fe || W || ee || Rl.includes(oe) && (Wt(G, { propagation: !1 }), de(), y = !1, n());
    }, ue = (G, oe) => {
      const { type: fe } = G || {};
      if (!e.disabled && !e.readonly) {
        if (ae(G) && fe === "mousedown" && G.button)
          return;
        de(), oe(1);
        const W = F.value, ee = C.value, E = S.value, j = B.value;
        i = setTimeout(() => {
          let U = 0;
          d = setInterval(() => {
            oe(U < W ? 1 : ee), U++;
          }, j);
        }, E);
      }
    }, ae = (G) => G.type === "mouseup" || G.type === "mousedown", me = (G) => {
      ae(G) && G.type === "mouseup" && G.button || (Wt(G, { propagation: !1 }), de(), te(!1), n());
    }, te = (G) => {
      try {
        Fl(G, [document.body, "mouseup", me, !1]), Fl(G, [document.body, "touchend", me, !1]);
      } catch {
        return 0;
      }
    }, de = () => {
      clearTimeout(i), clearInterval(d), i = void 0, d = void 0;
    }, ye = (G, oe, fe, W, ee, E, j) => {
      const U = ge(fe, {
        props: { scale: a.value ? 1.5 : 1.25 },
        attrs: { "aria-hidden": !0 }
      }), ce = { hasFocus: a.value }, Y = (se) => {
        !e.disabled && !e.readonly && (Wt(se, { propagation: !1 }), te(!0), ue(se, G));
      };
      return ge(
        "button",
        {
          class: [{ "py-0": !e.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
          tabindex: "-1",
          type: "button",
          disabled: e.disabled || e.readonly || E,
          "aria-disabled": e.disabled || e.readonly || E ? !0 : null,
          "aria-controls": o.value,
          "aria-label": oe || null,
          "aria-keyshortcuts": ee || null,
          onmousedown: Y,
          ontouchstart: Y
          // 'ref': keyRef,
        },
        [at(j, ce) || U]
      );
    };
    return () => {
      const G = ye(
        O,
        e.labelIncrement,
        ge(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-plus",
            viewBox: "0 0 16 16"
          },
          ge("path", {
            d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
          })
        ),
        "inc",
        "ArrowUp",
        !1,
        "increment"
      ), oe = ye(
        q,
        e.labelDecrement,
        ge(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-dash",
            viewBox: "0 0 16 16"
          },
          ge("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
        ),
        "dec",
        "ArrowDown",
        !1,
        "decrement"
      ), fe = [];
      e.name && !e.disabled && fe.push(
        ge("input", {
          type: "hidden",
          name: e.name,
          form: e.form || null,
          // TODO: Should this be set to '' if value is out of range?
          value: $.value,
          key: "hidden"
        })
      );
      const W = ge(
        // We use 'output' element to make this accept a `<label for="id">` (Except IE)
        "output",
        {
          class: [
            { "d-flex": e.vertical },
            { "align-self-center": !e.vertical },
            { "align-items-center": e.vertical },
            { "border-top": e.vertical },
            { "border-bottom": e.vertical },
            { "border-start": !e.vertical },
            { "border-end": !e.vertical },
            "flex-grow-1"
          ],
          ...I.value,
          key: "output"
          // ref: 'spinner',
        },
        [
          ge(
            "bdi",
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore How can we narrow this type down
            v.value ? _.value(r.value) : e.placeholder || ""
          )
        ]
      );
      return ge(
        "div",
        {
          class: [
            "b-form-spinbutton form-control",
            { disabled: e.disabled },
            { readonly: e.readonly },
            { focus: a },
            { "d-inline-flex": e.inline || e.vertical },
            { "d-flex": !e.inline && !e.vertical },
            { "align-items-stretch": !e.vertical },
            { "flex-column": e.vertical },
            e.size ? `form-control-${e.size}` : null
            // this.stateClass //TODO
          ],
          ...L.value,
          onkeydown: Q,
          onkeyup: X
          // We use capture phase (`!` prefix) since focus and blur do not bubble
          // 'focus': onFocusBlur, //TODO
          // 'blur': onFocusBlur, //TODO
        },
        e.vertical ? [G, fe, W, oe] : [oe, fe, W, G]
      );
    };
  }
}), Zu = ["id"], Cn = /* @__PURE__ */ x({
  __name: "BFormTag",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 },
    noRemove: { type: [String, Boolean], default: !1 },
    pill: { type: [String, Boolean], default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const l = e, a = Oe(), o = ke(() => l.id), n = u(() => l.disabled), s = u(() => l.noRemove), r = u(() => l.pill), i = w(
      () => {
        var b;
        return ((((b = a.default) == null ? void 0 : b.call(a)[0].children) ?? "").toString() || l.title) ?? "";
      }
    ), d = N(() => `${o.value}taglabel__`), y = w(() => ({
      [`text-bg-${l.variant}`]: l.variant !== null,
      "rounded-pill": r.value,
      disabled: n.value
    }));
    return (b, c) => (p(), M(ne(b.tag), {
      id: g(o),
      title: i.value,
      class: z(["badge b-form-tag d-inline-flex align-items-center mw-100", y.value]),
      "aria-labelledby": d.value
    }, {
      default: D(() => [
        Z("span", {
          id: d.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          A(b.$slots, "default", {}, () => [
            ie(J(i.value), 1)
          ])
        ], 8, Zu),
        !g(n) && !g(s) ? (p(), M(Nt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": b.removeLabel,
          class: "b-form-tag-remove",
          "aria-describedby": d.value,
          "aria-controls": b.id,
          onClick: c[0] || (c[0] = (h) => t("remove", i.value))
        }, null, 8, ["aria-label", "aria-describedby", "aria-controls"])) : K("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Qu = ["id"], ed = ["id", "for", "aria-live"], td = ["id", "aria-live"], ad = ["id"], ld = ["aria-controls"], od = {
  role: "group",
  class: "d-flex"
}, nd = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"], sd = ["disabled"], rd = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, id = {
  key: 0,
  class: "d-block invalid-feedback"
}, ud = {
  key: 1,
  class: "form-text text-body-secondary"
}, dd = {
  key: 2,
  class: "form-text text-body-secondary"
}, cd = ["name", "value"], fd = /* @__PURE__ */ x({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: [String, Boolean], default: !1 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: { default: void 0 },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    noAddOnEnter: { type: [String, Boolean], default: !1 },
    noOuterFocus: { type: [String, Boolean], default: !1 },
    noTagRemove: { type: [String, Boolean], default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    separator: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    size: { default: "md" },
    tagClass: { default: void 0 },
    tagPills: { type: [String, Boolean], default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l), n = ke(), s = u(() => a.addOnChange), r = u(() => a.autofocus), i = u(() => a.disabled), d = u(() => a.noAddOnEnter), y = u(() => a.noOuterFocus), b = u(() => a.noTagRemove), c = u(() => a.removeOnDelete), h = u(() => a.required), S = u(() => a.state), B = u(() => a.tagPills), F = Be(N(() => a.limit ?? NaN)), C = Bt(S), V = R(null), { focused: T } = Ne(V, {
      initialValue: r.value
    }), $ = N(() => a.inputId || `${n.value}input__`), m = R(o.value), k = R(""), f = R(o.value.length > 0), _ = R(""), L = R([]), v = R([]), I = R([]), H = w(() => [
      C.value,
      {
        [`form-control-${a.size}`]: a.size !== "md",
        disabled: i.value,
        focus: T.value
      }
    ]), O = w(() => m.value.includes(k.value)), q = w(
      () => k.value === "" ? !1 : !a.tagValidator(k.value)
    ), Q = N(() => m.value.length === F.value), X = N(() => !q.value && !O.value), ue = w(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: W,
      disableAddButton: X.value,
      disabled: i.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: I.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: i.value,
        form: a.form,
        id: $,
        value: k
      },
      inputHandlers: {
        input: de,
        keydown: G,
        change: ye
      },
      inputId: $,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: v.value,
      isDuplicate: O.value,
      isInvalid: q.value,
      isLimitReached: Q.value,
      limitTagsText: a.limitTagsText,
      limit: F.value,
      noTagRemove: b.value,
      placeholder: a.placeholder,
      removeTag: ee,
      required: h.value,
      separator: a.separator,
      size: a.size,
      state: S.value,
      tagClass: a.tagClass,
      tagPills: B.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: m.value
    }));
    re(o, (E) => {
      m.value = E;
    });
    const ae = (E) => {
      if (i.value) {
        E.target.blur();
        return;
      }
      l("focusin", E);
    }, me = (E) => {
      i.value || y.value || (T.value = !0, l("focus", E));
    }, te = (E) => {
      T.value = !1, l("blur", E);
    }, de = (E) => {
      var U, ce;
      const j = typeof E == "string" ? E : E.target.value;
      if (f.value = !1, (U = a.separator) != null && U.includes(j.charAt(0)) && j.length > 0) {
        V.value && (V.value.value = "");
        return;
      }
      if (k.value = j, (ce = a.separator) != null && ce.includes(j.charAt(j.length - 1))) {
        W(j.slice(0, j.length - 1));
        return;
      }
      L.value = a.tagValidator(j) && !O.value ? [j] : [], v.value = a.tagValidator(j) ? [] : [j], I.value = O.value ? [j] : [], l("tag-state", L.value, v.value, I.value);
    }, ye = (E) => {
      s.value && (de(E), O.value || W(k.value));
    }, G = (E) => {
      if (E.key === "Enter" && !d.value) {
        W(k.value);
        return;
      }
      (E.key === "Backspace" || E.key === "Delete") && c.value && k.value === "" && f.value && m.value.length > 0 ? ee(m.value[m.value.length - 1]) : f.value = !0;
    };
    je(G, { target: V });
    const oe = w(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), fe = w(() => {
      if (oe.value)
        return new RegExp(`[${is(oe.value)}]+`);
    }), W = (E) => {
      E = (E ?? k.value).trim();
      const j = fe.value ? E.split(fe.value).map((Y) => Y.trim()) : [E], U = [];
      for (const Y of j)
        if (!(Y === "" || O.value || !a.tagValidator(Y))) {
          if (F.value && Q.value)
            break;
          U.push(Y);
        }
      const ce = [...o.value, ...U];
      k.value = "", f.value = !0, o.value = ce, l("input", ce), T.value = !0;
    }, ee = (E) => {
      const j = m.value.indexOf((E == null ? void 0 : E.toString()) ?? "");
      _.value = m.value.splice(j, 1).toString(), o.value = m.value;
    };
    return t({
      element: V,
      focus: () => {
        T.value = !0;
      },
      blur: () => {
        T.value = !1;
      }
    }), (E, j) => (p(), P("div", {
      id: g(n),
      class: z(["b-form-tags form-control h-auto", H.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: ae,
      onFocusout: j[1] || (j[1] = (U) => l("focusout", U))
    }, [
      Z("output", {
        id: `${g(n)}selected_tags__`,
        class: "visually-hidden",
        for: $.value,
        "aria-live": g(T) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, J(m.value.join(", ")), 9, ed),
      Z("div", {
        id: `${g(n)}removed_tags__`,
        role: "status",
        "aria-live": g(T) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + J(E.tagRemovedLabel) + ") " + J(_.value), 9, td),
      A(E.$slots, "default", Ve(Pe(ue.value)), () => [
        Z("ul", {
          id: `${g(n)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (p(!0), P(ve, null, he(m.value, (U, ce) => A(E.$slots, "tag", {
            key: ce,
            tag: U,
            tagClass: E.tagClass,
            tagVariant: E.tagVariant,
            tagPills: g(B),
            removeTag: ee
          }, () => [
            (p(), M(Cn, {
              key: U,
              class: z(E.tagClass),
              tag: "li",
              variant: E.tagVariant,
              pill: E.tagPills,
              onRemove: ee
            }, {
              default: D(() => [
                ie(J(U), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          Z("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${g(n)}tag_list__`
          }, [
            Z("div", od, [
              Z("input", le({
                id: $.value,
                ref_key: "input",
                ref: V,
                disabled: g(i),
                value: k.value,
                type: E.inputType,
                placeholder: E.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, E.inputAttrs, {
                form: E.form,
                required: g(h) || void 0,
                "aria-required": g(h) || void 0,
                onInput: de,
                onChange: ye,
                onFocus: me,
                onBlur: te
              }), null, 16, nd),
              X.value ? (p(), P("button", {
                key: 0,
                type: "button",
                class: z(["btn b-form-tags-button py-0", [
                  E.inputClass,
                  {
                    [`btn-${E.addButtonVariant}`]: E.addButtonVariant !== null,
                    "disabled invisible": k.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: g(i) || k.value.length === 0 || Q.value,
                onClick: j[0] || (j[0] = (U) => W(k.value))
              }, [
                A(E.$slots, "add-button-text", {}, () => [
                  ie(J(E.addButtonText), 1)
                ])
              ], 10, sd)) : K("", !0)
            ])
          ], 8, ld)
        ], 8, ad),
        Z("div", rd, [
          q.value ? (p(), P("div", id, J(E.invalidTagText) + ": " + J(k.value), 1)) : K("", !0),
          O.value ? (p(), P("small", ud, J(E.duplicateTagText) + ": " + J(k.value), 1)) : K("", !0),
          m.value.length === E.limit ? (p(), P("small", dd, "Tag limit reached")) : K("", !0)
        ])
      ]),
      E.name ? (p(!0), P(ve, { key: 0 }, he(m.value, (U, ce) => (p(), P("input", {
        key: ce,
        type: "hidden",
        name: E.name,
        value: U
      }, null, 8, cd))), 128)) : K("", !0)
    ], 42, Qu));
  }
}), vd = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"], pd = /* @__PURE__ */ x({
  __name: "BFormTextarea",
  props: {
    noResize: { type: [String, Boolean], default: !1 },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    form: { default: void 0 },
    debounce: { default: 0 },
    debounceMaxWait: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: [String, Boolean], default: !1 },
    lazyFormatter: { type: [String, Boolean], default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: [String, Boolean], default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: [String, Boolean], default: !1 },
    readonly: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    trim: { type: [String, Boolean], default: !1 }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { expose: t, emit: l }) {
    const a = e, { input: o, computedId: n, computedAriaInvalid: s, onInput: r, onChange: i, onBlur: d, focus: y, blur: b } = Zo(a, l), c = u(() => a.disabled), h = u(() => a.required), S = u(() => a.readonly), B = u(() => a.plaintext), F = u(() => a.noResize), C = u(() => a.state), V = Bt(C), T = w(() => [
      V.value,
      {
        "form-control": !a.plaintext,
        "form-control-plaintext": a.plaintext,
        [`form-control-${a.size}`]: !!a.size
      }
    ]), $ = w(() => ({
      resize: F.value ? "none" : void 0
    }));
    return t({
      element: o,
      focus: y,
      blur: b
    }), (m, k) => (p(), P("textarea", {
      id: g(n),
      ref_key: "input",
      ref: o,
      class: z(T.value),
      name: m.name || void 0,
      form: m.form || void 0,
      disabled: g(c),
      placeholder: m.placeholder,
      required: g(h) || void 0,
      autocomplete: m.autocomplete || void 0,
      readonly: g(S) || g(B),
      "aria-required": m.required || void 0,
      "aria-invalid": g(s),
      rows: m.rows,
      style: xe($.value),
      wrap: m.wrap || void 0,
      onInput: k[0] || (k[0] = (f) => g(r)(f)),
      onChange: k[1] || (k[1] = (f) => g(i)(f)),
      onBlur: k[2] || (k[2] = (f) => g(d)(f))
    }, null, 46, vd));
  }
}), md = {
  key: 0,
  class: "input-group-text"
}, gd = ["innerHTML"], yd = { key: 1 }, bd = {
  key: 0,
  class: "input-group-text"
}, hd = ["innerHTML"], Bd = { key: 1 }, Sd = /* @__PURE__ */ x({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = w(() => ({
      [`input-group-${t.size}`]: t.size !== "md"
    })), a = N(() => !!t.append || !!t.appendHtml), o = N(() => !!t.prepend || !!t.prependHtml);
    return (n, s) => (p(), M(ne(n.tag), {
      id: n.id,
      class: z(["input-group", l.value]),
      role: "group"
    }, {
      default: D(() => [
        A(n.$slots, "prepend", {}, () => [
          o.value ? (p(), P("span", md, [
            n.prependHtml ? (p(), P("span", {
              key: 0,
              innerHTML: n.prependHtml
            }, null, 8, gd)) : (p(), P("span", yd, J(n.prepend), 1))
          ])) : K("", !0)
        ]),
        A(n.$slots, "default"),
        A(n.$slots, "append", {}, () => [
          a.value ? (p(), P("span", bd, [
            n.appendHtml ? (p(), P("span", {
              key: 0,
              innerHTML: n.appendHtml
            }, null, 8, hd)) : (p(), P("span", Bd, J(n.append), 1))
          ])) : K("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), kn = /* @__PURE__ */ x({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (p(), M(ne(t.tag), { class: "input-group-text" }, {
      default: D(() => [
        A(t.$slots, "default", {}, () => [
          ie(J(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), ol = /* @__PURE__ */ x({
  __name: "BInputGroupAddon",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.isText);
    return (a, o) => g(l) ? (p(), M(kn, { key: 0 }, {
      default: D(() => [
        A(a.$slots, "default")
      ]),
      _: 3
    })) : A(a.$slots, "default", { key: 1 });
  }
}), wd = /* @__PURE__ */ x({
  __name: "BInputGroupAppend",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    return (t, l) => (p(), M(ol, Ve(Pe(t.$props)), {
      default: D(() => [
        A(t.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Cd = /* @__PURE__ */ x({
  __name: "BInputGroupPrepend",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    return (t, l) => (p(), M(ol, Ve(Pe(t.$props)), {
      default: D(() => [
        A(t.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), kd = /* @__PURE__ */ x({
  __name: "BListGroup",
  props: {
    flush: { type: [String, Boolean], default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { type: [String, Boolean], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = u(() => t.flush), a = u(() => t.numbered), o = w(() => {
      const s = l.value ? !1 : t.horizontal;
      return {
        "list-group-flush": l.value,
        "list-group-horizontal": s === !0,
        [`list-group-horizontal-${s}`]: typeof s == "string",
        "list-group-numbered": a.value
      };
    }), n = N(() => a.value === !0 ? "ol" : t.tag);
    return Ue(po, {
      numbered: a
    }), (s, r) => (p(), M(ne(n.value), {
      class: z(["list-group", o.value])
    }, {
      default: D(() => [
        A(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), $d = /* @__PURE__ */ x({
  __name: "BListGroupItem",
  props: {
    action: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    active: { type: [String, Boolean], default: !1 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: null },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean] }
  },
  setup(e) {
    const t = e, l = Zl(), a = Le(po, null), o = u(() => t.action), n = u(() => t.active), s = u(() => t.button), r = u(() => t.disabled), { computedLink: i } = ht(t), d = N(() => !s.value && i.value), y = w(
      () => a != null && a.numbered.value ? "li" : s.value ? "button" : d.value ? tt : t.tag
    ), b = w(
      () => o.value || d.value || s.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), c = w(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== null,
      "list-group-item-action": b.value,
      active: n.value,
      disabled: r.value
    })), h = w(() => {
      const S = {};
      return s.value && ((!l || !l.type) && (S.type = "button"), r.value && (S.disabled = !0)), S;
    });
    return (S, B) => (p(), M(ne(y.value), le({
      class: ["list-group-item", c.value],
      "aria-current": g(n) ? !0 : void 0,
      "aria-disabled": g(r) ? !0 : void 0,
      target: d.value ? S.target : void 0,
      href: g(s) ? void 0 : S.href,
      to: g(s) ? void 0 : S.to
    }, h.value), {
      default: D(() => [
        A(S.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), nl = /* @__PURE__ */ x({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: [String, Boolean], default: !1 },
    noCenter: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    noWrap: { type: [String, Boolean], default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    rounded: { type: [Boolean, String], default: !1 },
    show: { type: [String, Boolean], default: !1 },
    spinnerSmall: { type: [String, Boolean], default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    noSpinner: { type: [String, Boolean], default: !1 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const l = e, a = { top: 0, left: 0, bottom: 0, right: 0 }, o = u(() => l.fixed), n = u(() => l.noSpinner), s = u(() => l.noCenter), r = u(() => l.noWrap), i = u(() => l.show), d = u(() => l.spinnerSmall), y = N(
      () => l.rounded === !0 || l.rounded === "" ? "rounded" : l.rounded === !1 ? "" : `rounded-${l.rounded}`
    ), b = N(
      () => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : ""
    ), c = N(() => i.value ? !0 : null), h = w(() => ({
      type: l.spinnerType,
      variant: l.spinnerVariant,
      small: d.value
    })), S = w(() => ({
      ...a,
      zIndex: l.zIndex || 10
    })), B = w(() => ({
      "position-absolute": !r.value || !o.value,
      "position-fixed": r.value && o.value
    })), F = w(() => [b.value, y.value]), C = w(() => ({
      ...a,
      opacity: l.opacity,
      backgroundColor: l.bgColor || void 0,
      backdropFilter: l.blur ? `blur(${l.blur})` : void 0
    })), V = w(
      () => s.value ? a : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (T, $) => (p(), M(ne(T.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": c.value
    }, {
      default: D(() => [
        A(T.$slots, "default"),
        be(Pt, {
          "no-fade": T.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onOnAfterEnter: $[1] || ($[1] = (m) => t("shown")),
          onOnAfterLeave: $[2] || ($[2] = (m) => t("hidden"))
        }, {
          default: D(() => [
            g(i) ? (p(), M(ne(T.overlayTag), {
              key: 0,
              class: z(["b-overlay", B.value]),
              style: xe(S.value),
              onClick: $[0] || ($[0] = (m) => t("click", m))
            }, {
              default: D(() => [
                Z("div", {
                  class: z(["position-absolute", F.value]),
                  style: xe(C.value)
                }, null, 6),
                Z("div", {
                  class: "position-absolute",
                  style: xe(V.value)
                }, [
                  A(T.$slots, "overlay", Ve(Pe(h.value)), () => [
                    g(n) ? K("", !0) : (p(), M(pa, Ve(le({ key: 0 }, h.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : K("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), _d = ["id", "aria-labelledby", "aria-describedby"], Td = ["id"], Ml = 1056, Vd = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BModal",
  props: {
    bodyVariant: { default: null },
    bodyBgVariant: { default: null },
    bodyClass: { default: void 0 },
    bodyTextVariant: { default: null },
    busy: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { type: [String, Boolean], default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: [String, Boolean], default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerVariant: { default: null },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    headerVariant: { default: null },
    headerTextVariant: { default: null },
    hideBackdrop: { type: [String, Boolean], default: !1 },
    hideFooter: { type: [String, Boolean], default: !1 },
    hideHeader: { type: [String, Boolean], default: !1 },
    hideHeaderClose: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    modalClass: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    noCloseOnBackdrop: { type: [String, Boolean], default: !1 },
    noCloseOnEsc: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    autoFocus: { type: [String, Boolean], default: !0 },
    okDisabled: { type: [String, Boolean], default: !1 },
    okOnly: { type: [String, Boolean], default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: [String, Boolean], default: !1 },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: [String, Boolean], default: !1 },
    titleTag: { default: "h5" },
    autoFocusButton: { default: void 0 },
    teleportDisabled: { type: [String, Boolean], default: !1 },
    teleportTo: { default: "body" },
    bodyScrolling: { type: [String, Boolean], default: !1 },
    backdropVariant: { default: void 0 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Oe(), n = ke(() => a.id, "modal"), s = Se(a, "modelValue", l, { passive: !0 }), r = u(() => a.busy), i = u(() => a.lazy), d = u(() => a.cancelDisabled), y = u(() => a.centered), b = u(() => a.hideBackdrop), c = u(() => a.hideFooter), h = u(() => a.hideHeader), S = u(() => a.hideHeaderClose), B = u(s), F = u(() => a.noCloseOnBackdrop), C = u(() => a.noCloseOnEsc), V = u(() => a.noFade), T = u(() => a.autoFocus), $ = u(() => a.okDisabled), m = u(() => a.okOnly), k = u(() => a.scrollable), f = u(() => a.titleSrOnly), _ = u(() => a.teleportDisabled), L = u(() => a.bodyScrolling), v = R(null), I = R(null), H = R(null), O = R(null), q = R(B.value), Q = R(!1);
    je(
      "Escape",
      () => {
        Ce("esc");
      },
      { target: v }
    ), en(B, L);
    const { focused: X } = Ne(v, {
      initialValue: B.value && a.autoFocusButton === void 0
    }), { focused: ue } = Ne(I, {
      initialValue: B.value && a.autoFocusButton === "ok"
    }), { focused: ae } = Ne(H, {
      initialValue: B.value && a.autoFocusButton === "cancel"
    }), { focused: me } = Ne(O, {
      initialValue: B.value && a.autoFocusButton === "close"
    }), te = w(() => [
      a.modalClass,
      {
        fade: !V.value,
        show: q.value
      }
    ]), de = N(
      () => i.value === !1 || i.value === !0 && Q.value === !0 || i.value === !0 && B.value === !0
    ), ye = N(
      () => a.backdropVariant !== void 0 ? a.backdropVariant : b.value ? "transparent" : "dark"
    ), G = N(() => !Ae(o["header-close"])), oe = w(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === !0,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": y.value,
        "modal-dialog-scrollable": k.value
      }
    ]), fe = qe(() => ({
      bgVariant: a.bodyBgVariant,
      textVariant: a.bodyTextVariant,
      variant: a.bodyVariant
    })), W = w(() => [a.bodyClass, fe.value]), ee = qe(() => ({
      bgVariant: a.headerBgVariant,
      textVariant: a.headerTextVariant,
      variant: a.headerVariant
    })), E = w(() => [
      a.headerClass,
      ee.value,
      {
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null
      }
    ]), j = w(() => [a.headerCloseClass]), U = w(() => ({
      variant: G.value ? a.headerCloseVariant : void 0,
      class: j.value
    })), ce = qe(() => ({
      bgVariant: a.footerBgVariant,
      textVariant: a.footerTextVariant,
      variant: a.footerVariant
    })), Y = w(() => [
      a.footerClass,
      ce.value,
      {
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null
      }
    ]), se = w(() => [
      a.titleClass,
      {
        "visually-hidden": f.value
      }
    ]), $e = N(() => d.value || r.value), it = N(() => $.value || r.value), De = (pe, Te = {}) => new Ft(pe, {
      cancelable: !1,
      target: v.value || null,
      relatedTarget: null,
      trigger: null,
      ...Te,
      componentId: n.value
    }), Ce = (pe = "") => {
      const Te = De("hide", { cancelable: pe !== "", trigger: pe });
      if (pe === "ok" && l(pe, Te), pe === "cancel" && l(pe, Te), pe === "close" && l(pe, Te), l("hide", Te), Te.defaultPrevented || pe === "backdrop" && F.value || pe === "esc" && C.value) {
        l("hide-prevented");
        return;
      }
      s.value = !1;
    }, ga = () => {
      const pe = De("show", { cancelable: !0 });
      if (l("show", pe), pe.defaultPrevented) {
        s.value = !1, l("show-prevented");
        return;
      }
      s.value = !0;
    }, Pn = () => {
      T.value !== !1 && (a.autoFocusButton === "ok" ? ue.value = !0 : a.autoFocusButton === "close" ? me.value = !0 : a.autoFocusButton === "cancel" ? ae.value = !0 : X.value = !0);
    }, Nn = () => ga(), Ln = () => {
      q.value = !0, Pn(), l("shown", De("shown")), i.value === !0 && (Q.value = !0);
    }, In = () => {
      q.value = !1;
    }, Hn = () => {
      l("hidden", De("hidden")), i.value === !0 && (Q.value = !1);
    }, { activePosition: zn, activeModalCount: xn } = Gr(q, n), Rn = w(() => ({
      // Make sure that newly opened modals have a higher z-index than currently active ones.
      // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').
      //
      // This means inactive modals will already be higher than active ones when opened.
      "z-index": q.value ? Ml - (xn.value - zn.value) : Ml
    }));
    we(v, "bv-toggle", () => {
      B.value ? Ce() : ga();
    });
    const St = It({
      cancel: () => Ce("cancel"),
      close: () => Ce("close"),
      hide: Ce,
      ok: () => Ce("ok"),
      visible: B
    });
    return t({
      hide: Ce,
      show: ga,
      id: n.value
    }), (pe, Te) => (p(), M(sa, {
      to: pe.teleportTo,
      disabled: g(_)
    }, [
      be(Pt, {
        "no-fade": !0,
        "trans-props": { enterToClass: "show" },
        onBeforeEnter: Nn,
        onAfterEnter: Ln,
        onLeave: In,
        onAfterLeave: Hn
      }, {
        default: D(() => [
          vt(Z("div", le({
            id: g(n),
            ref_key: "element",
            ref: v,
            class: ["modal", te.value],
            role: "dialog",
            "aria-labelledby": g(h) ? void 0 : `${g(n)}-label`,
            "aria-describedby": `${g(n)}-body`,
            tabindex: "-1"
          }, pe.$attrs, { style: Rn.value }), [
            Z("div", {
              class: z(["modal-dialog", oe.value])
            }, [
              de.value ? (p(), P("div", {
                key: 0,
                class: z(["modal-content", pe.contentClass])
              }, [
                g(h) ? K("", !0) : (p(), P("div", {
                  key: 0,
                  class: z(["modal-header", E.value])
                }, [
                  A(pe.$slots, "header", Ve(Pe(St)), () => [
                    (p(), M(ne(pe.titleTag), {
                      id: `${g(n)}-label`,
                      class: z(["modal-title", se.value])
                    }, {
                      default: D(() => [
                        A(pe.$slots, "title", Ve(Pe(St)), () => [
                          ie(J(pe.title), 1)
                        ], !0)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    g(S) ? K("", !0) : (p(), P(ve, { key: 0 }, [
                      G.value ? (p(), M(ut, le({ key: 0 }, U.value, {
                        onClick: Te[0] || (Te[0] = (Dt) => Ce("close"))
                      }), {
                        default: D(() => [
                          A(pe.$slots, "header-close", {}, void 0, !0)
                        ]),
                        _: 3
                      }, 16)) : (p(), M(Nt, le({
                        key: 1,
                        "aria-label": pe.headerCloseLabel
                      }, U.value, {
                        onClick: Te[1] || (Te[1] = (Dt) => Ce("close"))
                      }), null, 16, ["aria-label"]))
                    ], 64))
                  ], !0)
                ], 2)),
                Z("div", {
                  id: `${g(n)}-body`,
                  class: z(["modal-body", W.value])
                }, [
                  A(pe.$slots, "default", Ve(Pe(St)), void 0, !0)
                ], 10, Td),
                g(c) ? K("", !0) : (p(), P("div", {
                  key: 1,
                  class: z(["modal-footer", Y.value])
                }, [
                  A(pe.$slots, "footer", Ve(Pe(St)), () => [
                    A(pe.$slots, "cancel", Ve(Pe(St)), () => [
                      g(m) ? K("", !0) : (p(), M(ut, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: H,
                        disabled: $e.value,
                        size: pe.buttonSize,
                        variant: pe.cancelVariant,
                        onClick: Te[2] || (Te[2] = (Dt) => Ce("cancel"))
                      }, {
                        default: D(() => [
                          ie(J(pe.cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], !0),
                    A(pe.$slots, "ok", Ve(Pe(St)), () => [
                      be(ut, {
                        ref_key: "okButton",
                        ref: I,
                        disabled: it.value,
                        size: pe.buttonSize,
                        variant: pe.okVariant,
                        onClick: Te[3] || (Te[3] = (Dt) => Ce("ok"))
                      }, {
                        default: D(() => [
                          ie(J(pe.okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], !0)
                  ], !0)
                ], 2))
              ], 2)) : K("", !0)
            ], 2),
            A(pe.$slots, "backdrop", {}, () => [
              be(nl, {
                variant: ye.value,
                show: g(B),
                "no-spinner": "",
                fixed: "",
                "no-wrap": "",
                blur: null,
                onClick: Te[4] || (Te[4] = (Dt) => Ce("backdrop"))
              }, null, 8, ["variant", "show"])
            ], !0)
          ], 16, _d), [
            [ra, g(B)]
          ])
        ]),
        _: 3
      })
    ], 8, ["to", "disabled"]));
  }
});
const Ad = /* @__PURE__ */ ma(Vd, [["__scopeId", "data-v-49f7b865"]]), Od = /* @__PURE__ */ x({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: [String, Boolean], default: !1 },
    fill: { type: [String, Boolean], default: !1 },
    justified: { type: [String, Boolean], default: !1 },
    pills: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tabs: { type: [String, Boolean], default: !1 },
    tag: { default: "ul" },
    vertical: { type: [String, Boolean], default: !1 },
    underline: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.cardHeader), a = u(() => t.fill), o = u(() => t.justified), n = u(() => t.pills), s = u(() => t.small), r = u(() => t.tabs), i = u(() => t.vertical), d = Mt(() => t.align), y = u(() => t.underline), b = w(() => ({
      "nav-tabs": r.value,
      "nav-pills": n.value && !r.value,
      "card-header-tabs": !i.value && l.value && r.value,
      "card-header-pills": !i.value && l.value && n.value && !r.value,
      "flex-column": i.value,
      "nav-fill": !i.value && a.value,
      "nav-justified": !i.value && o.value,
      [d.value]: !i.value && t.align !== void 0,
      small: s.value,
      "nav-underline": y.value
    }));
    return (c, h) => (p(), M(ne(c.tag), {
      class: z(["nav", b.value])
    }, {
      default: D(() => [
        A(c.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ed = { class: "d-flex flex-row align-items-center flex-wrap" }, Fd = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    id: { default: void 0 },
    floating: { type: [String, Boolean], default: !1 },
    novalidate: { type: [String, Boolean], default: !1 },
    validated: { type: [String, Boolean], default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const l = (a) => {
      t("submit", a);
    };
    return (a, o) => (p(), P("li", Ed, [
      be(pn, le(a.$attrs, {
        id: a.id,
        floating: a.floating,
        role: a.role,
        novalidate: a.novalidate,
        validated: a.validated,
        class: "d-flex",
        onSubmit: Ha(l, ["prevent"])
      }), {
        default: D(() => [
          A(a.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "floating", "role", "novalidate", "validated", "onSubmit"])
    ]));
  }
}), Pd = { class: "nav-item" }, Nd = /* @__PURE__ */ x({
  __name: "BNavItem",
  props: {
    linkClass: { default: void 0 },
    linkAttrs: { default: void 0 },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = u(() => l.disabled), o = w(
      () => Da(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "icon",
        "opacity",
        "opacityHover",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "underlineVariant",
        "variant"
      ])
    );
    return (n, s) => (p(), P("li", Pd, [
      be(tt, le({
        class: ["nav-link", n.linkClass]
      }, { ...o.value, ...n.linkAttrs }, {
        "active-class": n.activeClass,
        tabindex: g(a) ? -1 : void 0,
        "aria-disabled": g(a) ? !0 : void 0,
        onClick: s[0] || (s[0] = (r) => t("click", r))
      }), {
        default: D(() => [
          A(n.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "active-class", "tabindex", "aria-disabled"])
    ]));
  }
}), Ld = { class: "nav-item dropdown" }, Id = /* @__PURE__ */ x({
  __name: "BNavItemDropdown",
  props: {
    ariaLabel: { default: void 0 },
    id: { default: void 0 },
    menuClass: { default: void 0 },
    size: { default: "md" },
    splitClass: { default: void 0 },
    splitVariant: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    block: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: !0 },
    dropup: { type: [String, Boolean], default: !1 },
    dropend: { type: [String, Boolean], default: !1 },
    dropstart: { type: [String, Boolean], default: !1 },
    center: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    noFlip: { type: [String, Boolean], default: !1 },
    noShift: { type: [String, Boolean], default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    split: { type: [String, Boolean], default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    splitDisabled: { type: [String, Boolean], default: void 0 },
    noCaret: { type: [String, Boolean], default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "link" },
    modelValue: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    splitTo: { default: void 0 },
    boundary: { default: "clippingAncestors" },
    container: {}
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = R(null), n = () => {
      var i;
      (i = o.value) == null || i.close();
    }, s = () => {
      var i;
      (i = o.value) == null || i.open();
    };
    return t({
      close: n,
      open: s,
      toggle: () => {
        var i;
        (i = o.value) == null || i.toggle();
      }
    }), (i, d) => (p(), P("li", Ld, [
      be(vn, le({
        ref_key: "dropdown",
        ref: o
      }, a, {
        "is-nav": "",
        onShow: d[0] || (d[0] = (y) => l("show", y)),
        onShown: d[1] || (d[1] = (y) => l("shown")),
        onHide: d[2] || (d[2] = (y) => l("hide", y)),
        onHidden: d[3] || (d[3] = (y) => l("hidden")),
        onHidePrevented: d[4] || (d[4] = (y) => l("hide-prevented")),
        onShowPrevented: d[5] || (d[5] = (y) => l("show-prevented")),
        onClick: d[6] || (d[6] = (y) => l("click", y)),
        onToggle: d[7] || (d[7] = (y) => l("toggle")),
        "onUpdate:modelValue": d[8] || (d[8] = (y) => l("update:modelValue", y))
      }), {
        "button-content": D(() => [
          A(i.$slots, "button-content")
        ]),
        "toggle-text": D(() => [
          A(i.$slots, "toggle-text")
        ]),
        default: D(() => [
          A(i.$slots, "default", {
            hide: n,
            show: s
          })
        ]),
        _: 3
      }, 16)
    ]));
  }
}), Hd = { class: "navbar-text" }, zd = /* @__PURE__ */ x({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (p(), P("li", Hd, [
      A(t.$slots, "default", {}, () => [
        ie(J(t.text), 1)
      ])
    ]));
  }
}), xd = /* @__PURE__ */ x({
  __name: "BNavbar",
  props: {
    fixed: { default: void 0 },
    print: { type: [String, Boolean], default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    variant: { default: null },
    container: { type: [String, Boolean], default: "fluid" },
    autoClose: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = e, l = u(() => t.print), a = N(() => t.tag === "nav" ? void 0 : "navigation"), o = w(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
    ), n = N(() => t.container === !0 ? "container" : "container-fluid"), s = w(() => ({
      "d-print": l.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      [`bg-${t.variant}`]: t.variant !== null,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${o.value}`]: o.value !== void 0
    }));
    return Ue(qa, {
      tag: N(() => t.tag),
      autoClose: N(() => t.autoClose)
    }), (r, i) => (p(), M(ne(r.tag), {
      class: z(["navbar", s.value]),
      role: a.value
    }, {
      default: D(() => [
        r.container !== !1 ? (p(), P("div", {
          key: 0,
          class: z(n.value)
        }, [
          A(r.$slots, "default")
        ], 2)) : A(r.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Rd = /* @__PURE__ */ x({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, { computedLink: l, computedLinkProps: a } = ht(t, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "variant",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), o = N(() => l.value ? tt : t.tag);
    return (n, s) => (p(), M(ne(o.value), le({ class: "navbar-brand" }, g(a)), {
      default: D(() => [
        A(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Md = /* @__PURE__ */ x({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: [String, Boolean], default: !1 },
    justified: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, l = u(() => t.fill), a = u(() => t.justified), o = u(() => t.small), n = Mt(() => t.align), s = w(() => ({
      "nav-fill": l.value,
      "nav-justified": a.value,
      [n.value]: t.align !== void 0,
      small: o.value
    }));
    return (r, i) => (p(), P("ul", {
      class: z(["navbar-nav", s.value])
    }, [
      A(r.$slots, "default")
    ], 2));
  }
}), Dl = (e, t) => e.setAttribute("data-bs-theme", t), Dd = {
  mounted(e, t) {
    Dl(e, t.value);
  },
  updated(e, t) {
    Dl(e, t.value);
  }
}, jd = (e, t) => {
  const { modifiers: l, arg: a, value: o } = e, n = Object.keys(l || {}), s = typeof o == "string" ? o.split(Xt) : o;
  if (Ts(t.tagName, "a")) {
    const r = Ma(t, "href") || "";
    as.test(r) && n.push(r.replace(ts, ""));
  }
  return Array.prototype.concat.apply([], [a, s]).forEach((r) => typeof r == "string" && n.push(r)), n.filter((r, i, d) => r && d.indexOf(r) === i);
}, qd = (e, t) => {
  e.forEach((l) => {
    const a = document.getElementById(l);
    a !== null && a.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => $n(e, t), 50);
}, $n = (e, t) => {
  let l = !1;
  e.forEach((a) => {
    const o = document.getElementById(a);
    o != null && o.classList.contains("show") && (l = !0), o != null && o.classList.contains("closing") && (l = !1);
  }), t.setAttribute("aria-expanded", l ? "true" : "false"), t.classList.remove(l ? "collapsed" : "not-collapsed"), t.classList.add(l ? "not-collapsed" : "collapsed");
}, jl = (e, t) => {
  const l = jd(t, e);
  e.__toggle && e.removeEventListener("click", e.__toggle), e.__toggle = () => qd(l, e), e.addEventListener("click", e.__toggle), e.setAttribute("aria-controls", l.join(" ")), $n(l, e);
}, Pa = {
  mounted: jl,
  updated: jl,
  unmounted(e) {
    e.removeEventListener("click", e.__toggle), e.removeAttribute("aria-controls"), e.removeAttribute("aria-expanded");
  }
}, Gd = {
  mounted(e, t) {
    if (!zt(t.value))
      return;
    const a = la(t.value, e);
    !a.content && !a.title || (e.$__state = R({
      ...Tt(t, e),
      ...a
    }), oa(e, t));
  },
  updated(e, t) {
    if (!zt(t.value))
      return;
    const a = la(t.value, e);
    if (!(!a.content && !a.title)) {
      if (!e.$__state) {
        e.$__state = R({
          ...Tt(t, e),
          ...a
        }), oa(e, t);
        return;
      }
      e.$__state.value = {
        ...Tt(t, e),
        ...a
      };
    }
  },
  beforeUnmount(e) {
    an(e);
  }
}, Wd = {
  mounted(e, t) {
    const l = zt(t.value);
    if (!l)
      return;
    const a = la(t.value, e);
    !a.content && !a.title || (e.$__state = R({
      noninteractive: !0,
      ...Tt(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: l
    }), oa(e, t));
  },
  updated(e, t) {
    const l = zt(t.value);
    if (!l)
      return;
    const a = la(t.value, e);
    if (!(!a.content && !a.title)) {
      if (!e.$__state) {
        e.$__state = R({
          noninteractive: !0,
          ...Tt(t, e),
          title: a.title ?? a.content ?? "",
          tooltip: l
        }), oa(e, t);
        return;
      }
      e.$__state.value = {
        noninteractive: !0,
        ...Tt(t, e),
        title: a.title ?? a.content ?? "",
        tooltip: l
      };
    }
  },
  beforeUnmount(e) {
    an(e);
  }
}, ql = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: Dd,
  vBModal: Pa,
  vBPopover: Gd,
  vBToggle: Pa,
  vBTooltip: Wd
}, Symbol.toStringTag, { value: "Module" })), Ud = ["disabled", "aria-label"], Xd = /* @__PURE__ */ Z("span", { class: "navbar-toggler-icon" }, null, -1), Kd = /* @__PURE__ */ x({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: [String, Boolean], default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = u(() => l.disabled), o = w(() => ({
      disabled: a.value
    })), n = (s) => {
      a.value || t("click", s);
    };
    return (s, r) => vt((p(), P("button", {
      class: z(["navbar-toggler", o.value]),
      type: "button",
      disabled: g(a),
      "aria-label": s.label,
      onClick: n
    }, [
      A(s.$slots, "default", {}, () => [
        Xd
      ])
    ], 10, Ud)), [
      [g(Pa), g(a) ? void 0 : s.target]
    ]);
  }
}), Jd = ["id", "aria-labelledby"], Yd = ["id"], Zd = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BOffcanvas",
  props: {
    modelValue: { type: [String, Boolean], default: !1 },
    bodyScrolling: { type: [String, Boolean], default: !1 },
    backdrop: { type: [String, Boolean], default: !0 },
    noCloseOnBackdrop: { type: [String, Boolean], default: !1 },
    noCloseOnEsc: { type: [String, Boolean], default: !1 },
    placement: { default: "start" },
    title: { default: void 0 },
    noHeaderClose: { type: [String, Boolean], default: !1 },
    noHeader: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    noFocus: { type: [String, Boolean], default: !1 },
    backdropVariant: { default: "dark" },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    bodyClass: { default: void 0 },
    footerClass: { default: void 0 },
    teleportDisabled: { type: [String, Boolean], default: !1 },
    teleportTo: { default: "body" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Oe(), n = Se(a, "modelValue", l, { passive: !0 }), s = u(n), r = u(() => a.bodyScrolling), i = u(() => a.backdrop), d = u(() => a.noHeaderClose), y = u(() => a.noHeader), b = u(() => a.noFocus), c = u(() => a.noCloseOnBackdrop), h = u(() => a.noCloseOnEsc), S = u(() => a.lazy), B = u(() => a.teleportDisabled), F = ke(() => a.id, "offcanvas");
    en(s, r);
    const C = R(null);
    je(
      "Escape",
      () => {
        O("esc");
      },
      { target: C }
    );
    const { focused: V } = Ne(C, {
      initialValue: s.value && b.value === !1
    }), T = R(s.value), $ = R(!1), m = N(() => i.value === !0 && s.value === !0), k = N(
      () => S.value === !1 || S.value === !0 && $.value === !0 || S.value === !0 && s.value === !0
    ), f = N(() => !Ae(o["header-close"])), _ = w(() => [
      { "text-reset": !f.value },
      a.headerCloseClass
    ]), L = w(() => ({
      variant: f.value ? a.headerCloseVariant : void 0,
      class: _.value
    })), v = N(() => !Ae(o.footer)), I = w(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: s.value && T.value === !0
      }
    ]), H = (te, de = {}) => new Ft(te, {
      cancelable: !1,
      target: C.value || null,
      relatedTarget: null,
      trigger: null,
      ...de,
      componentId: F.value
    }), O = (te = "") => {
      const de = H("hide", { cancelable: te !== "", trigger: te });
      if (te === "close" && l(te, de), te === "esc" && l(te, de), l("hide", de), de.defaultPrevented || te === "backdrop" && c.value || te === "esc" && h.value) {
        l("hide-prevented");
        return;
      }
      n.value = !1;
    }, q = () => {
      const te = H("show", { cancelable: !0 });
      if (l("show", te), te.defaultPrevented) {
        n.value = !1, l("show-prevented");
        return;
      }
      n.value = !0;
    }, Q = () => {
      _e(() => {
        b.value === !1 && (V.value = !0);
      });
    }, X = () => q(), ue = () => {
      T.value = !0, Q(), l("shown", H("shown")), S.value === !0 && ($.value = !0);
    }, ae = () => {
      T.value = !1;
    }, me = () => {
      l("hidden", H("hidden")), S.value === !0 && ($.value = !1);
    };
    return we(C, "bv-toggle", () => {
      s.value ? O() : q();
    }), t({
      hide: O,
      show: q
    }), (te, de) => (p(), M(sa, {
      to: te.teleportTo,
      disabled: g(B)
    }, [
      be(Pt, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: X,
        onAfterEnter: ue,
        onLeave: ae,
        onAfterLeave: me
      }, {
        default: D(() => [
          vt(Z("div", le({
            id: g(F),
            ref_key: "element",
            ref: C,
            "aria-modal": "true",
            role: "dialog",
            class: I.value,
            tabindex: "-1",
            "aria-labelledby": `${g(F)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, te.$attrs), [
            k.value ? (p(), P(ve, { key: 0 }, [
              g(y) ? K("", !0) : (p(), P("div", {
                key: 0,
                class: z(["offcanvas-header", te.headerClass])
              }, [
                A(te.$slots, "header", {
                  visible: g(s),
                  placement: te.placement,
                  hide: O
                }, () => [
                  Z("h5", {
                    id: `${g(F)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    A(te.$slots, "title", {
                      visible: g(s),
                      placement: te.placement,
                      hide: O
                    }, () => [
                      ie(J(te.title), 1)
                    ])
                  ], 8, Yd),
                  g(d) ? K("", !0) : (p(), P(ve, { key: 0 }, [
                    f.value ? (p(), M(ut, le({ key: 0 }, L.value, {
                      onClick: de[0] || (de[0] = (ye) => O("close"))
                    }), {
                      default: D(() => [
                        A(te.$slots, "header-close")
                      ]),
                      _: 3
                    }, 16)) : (p(), M(Nt, le({
                      key: 1,
                      "aria-label": te.headerCloseLabel
                    }, L.value, {
                      onClick: de[1] || (de[1] = (ye) => O("close"))
                    }), null, 16, ["aria-label"]))
                  ], 64))
                ])
              ], 2)),
              Z("div", {
                class: z(["offcanvas-body", te.bodyClass])
              }, [
                A(te.$slots, "default", {
                  visible: g(s),
                  placement: te.placement,
                  hide: O
                })
              ], 2),
              v.value ? (p(), P("div", {
                key: 1,
                class: z(te.footerClass)
              }, [
                A(te.$slots, "footer", {
                  visible: g(s),
                  placement: te.placement,
                  hide: O
                })
              ], 2)) : K("", !0)
            ], 64)) : K("", !0)
          ], 16, Jd), [
            [ra, g(n)]
          ])
        ]),
        _: 3
      }),
      A(te.$slots, "backdrop", {}, () => [
        be(nl, {
          variant: te.backdropVariant,
          show: m.value,
          fixed: "",
          "no-wrap": "",
          "no-spinner": "",
          onClick: de[2] || (de[2] = (ye) => O("backdrop"))
        }, null, 8, ["variant", "show"])
      ])
    ], 8, ["to", "disabled"]));
  }
}), Qd = 5, _n = 20, Tn = 0, Xe = 3, ec = "ellipsis-text", tc = "first-text", ac = "last-text", lc = "next-text", oc = "page", nc = "prev-text", Gl = (e) => Math.max(gt(e) || _n, 1), Wl = (e) => Math.max(gt(e) || Tn, 0), sc = (e, t) => {
  const l = gt(e) || 1;
  return l > t ? t : l < 1 ? 1 : l;
}, rc = x({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "â¦" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { type: String, default: "Â«" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { type: String, default: "Â»" },
    limit: { type: Number, default: Qd },
    modelValue: { type: Number, default: 1 },
    // V-model prop
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "âº" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: _n },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "â¹" },
    size: { type: String, default: "md" },
    totalRows: { type: Number, default: Tn }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: l }) {
    const a = Se(e, "modelValue", t), o = u(() => e.disabled), n = u(() => e.firstNumber), s = u(() => e.hideEllipsis), r = u(() => e.hideGotoEndButtons), i = u(() => e.lastNumber), d = u(() => e.pills), y = N(() => e.align === "fill" ? "start" : e.align), b = Mt(y), c = N(
      () => Math.ceil(Wl(e.totalRows) / Gl(e.perPage))
    ), h = w(() => {
      let k;
      return c.value - a.value + 2 < e.limit && e.limit > Xe ? k = c.value - B.value + 1 : k = a.value - Math.floor(B.value / 2), k < 1 ? k = 1 : k > c.value - B.value && (k = c.value - B.value + 1), e.limit <= Xe && i.value && c.value === k + B.value - 1 && (k = Math.max(k - 1, 1)), k;
    }), S = w(() => {
      const k = c.value - a.value;
      let f = !1;
      return k + 2 < e.limit && e.limit > Xe ? e.limit > Xe && (f = !0) : e.limit > Xe && (f = !!(!s.value || n.value)), h.value <= 1 && (f = !1), f && n.value && h.value < 4 && (f = !1), f;
    }), B = w(() => {
      let k = e.limit;
      return c.value <= e.limit ? k = c.value : a.value < e.limit - 1 && e.limit > Xe ? ((!s.value || i.value) && (k = e.limit - (n.value ? 0 : 1)), k = Math.min(k, e.limit)) : c.value - a.value + 2 < e.limit && e.limit > Xe ? (!s.value || n.value) && (k = e.limit - (i.value ? 0 : 1)) : e.limit > Xe && (k = e.limit - (s.value ? 0 : 2)), k;
    }), F = w(() => {
      const k = c.value - B.value;
      let f = !1;
      a.value < e.limit - 1 && e.limit > Xe ? (!s.value || i.value) && (f = !0) : e.limit > Xe && (f = !!(!s.value || i.value)), h.value > k && (f = !1);
      const _ = h.value + B.value - 1;
      return f && i.value && _ > c.value - 3 && (f = !1), f;
    }), C = It({
      pageSize: Gl(e.perPage),
      totalRows: Wl(e.totalRows),
      numberOfPages: c.value
    }), V = (k, f) => {
      if (f === a.value)
        return;
      const { target: _ } = k, L = new ot("page-click", {
        cancelable: !0,
        target: _
      });
      t("page-click", L, f), !L.defaultPrevented && (a.value = f);
    }, T = N(() => e.size ? `pagination-${e.size}` : ""), $ = N(() => d.value ? "b-pagination-pills" : "");
    re(a, (k) => {
      const f = sc(k, c.value);
      f !== a.value && (a.value = f);
    }), re(C, (k, f) => {
      k != null && (f.pageSize !== k.pageSize && f.totalRows === k.totalRows || f.numberOfPages !== k.numberOfPages && a.value > f.numberOfPages) && (a.value = 1);
    });
    const m = w(() => {
      const k = [];
      for (let f = 0; f < B.value; f++)
        k.push({ number: h.value + f, classes: null });
      return k;
    });
    return () => {
      const k = [], f = m.value.map((X) => X.number), _ = (X) => X === a.value, L = a.value < 1, v = e.align === "fill", I = (X, ue, ae, me, te, de) => {
        const ye = o.value || _(de) || L || X < 1 || X > c.value, G = X < 1 ? 1 : X > c.value ? c.value : X, oe = { disabled: ye, page: G, index: G - 1 }, fe = at(ae, oe, l) || me || "";
        return ge(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: ye,
                "flex-fill": v,
                "d-flex": v && !ye
              },
              te
            ]
          },
          // render inner content
          ge(
            ye ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !ye && v }],
              "aria-label": ue,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": ye ? !0 : null,
              role: "menuitem",
              type: ye ? null : "button",
              tabindex: ye ? null : "-1",
              onClick: (W) => {
                ye || V(W, G);
              }
            },
            fe
          )
        );
      }, H = (X) => ge(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            v ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${X ? "last" : "first"}`
        },
        [
          ge(
            "span",
            { class: ["page-link"] },
            at(ec, {}, l) || e.ellipsisText || "..."
          )
        ]
      ), O = (X, ue) => {
        const ae = _(X.number) && !L, me = o.value ? null : ae || L && ue === 0 ? "0" : "-1", te = {
          active: ae,
          disabled: o.value,
          page: X.number,
          index: X.number - 1,
          content: X.number
        }, de = at(oc, te, l) || X.number, ye = ge(
          o.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !o.value && v }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": o.value ? !0 : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${X.number}` : null,
            role: "menuitemradio",
            type: o.value ? null : "button",
            tabindex: me,
            onClick: (G) => {
              o.value || V(G, X.number);
            }
          },
          de
        );
        return ge(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: o.value,
                active: ae,
                "flex-fill": v,
                "d-flex": v && !o.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${X.number}`
          },
          ye
        );
      };
      if (!r.value && !n.value) {
        const X = I(
          1,
          e.labelFirstPage,
          tc,
          e.firstText,
          e.firstClass,
          1
        );
        k.push(X);
      }
      const q = I(
        a.value - 1,
        e.labelFirstPage,
        nc,
        e.prevText,
        e.prevClass,
        1
      );
      k.push(q), n.value && f[0] !== 1 && k.push(O({ number: 1 }, 0)), S.value && k.push(H(!1)), m.value.forEach((X, ue) => {
        const ae = S.value && n.value && f[0] !== 1 ? 1 : 0;
        k.push(O(X, ue + ae));
      }), F.value && k.push(H(!0)), i.value && f[f.length - 1] !== c.value && k.push(O({ number: c.value }, -1));
      const Q = I(
        a.value + 1,
        e.labelNextPage,
        lc,
        e.nextText,
        e.nextClass,
        c.value
      );
      if (k.push(Q), !i.value && !r.value) {
        const X = I(
          c.value,
          e.labelLastPage,
          ac,
          e.lastText,
          e.lastClass,
          c.value
        );
        k.push(X);
      }
      return ge(
        "ul",
        {
          class: ["pagination", T.value, b.value, $.value],
          role: "menubar",
          "aria-disabled": o.value,
          "aria-label": e.ariaLabel || null
        },
        k
      );
    };
  }
}), ze = /* @__PURE__ */ x({
  inheritAttrs: !1,
  __name: "BPlaceholder",
  props: {
    tag: { default: "span" },
    wrapperTag: { default: "span" },
    width: { default: void 0 },
    cols: { default: 12 },
    variant: { default: null },
    size: { default: "md" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, l = w(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.replace("%", "")
    ), a = w(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), o = w(() => ({
      [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,
      [`bg-${t.variant}`]: t.variant !== null,
      [`placeholder-${t.size}`]: t.size !== "md"
    })), n = w(() => ({
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), s = w(() => ({
      width: l.value === void 0 ? void 0 : `${l.value}%`
    }));
    return (r, i) => (p(), M(ne(r.wrapperTag), {
      class: z(n.value)
    }, {
      default: D(() => [
        (p(), M(ne(r.tag), le(r.$attrs, {
          class: ["placeholder", o.value],
          style: s.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), Vn = /* @__PURE__ */ x({
  __name: "BPlaceholderButton",
  props: {
    tag: { default: "div" },
    width: { default: void 0 },
    cols: { default: void 0 },
    variant: { default: "primary" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, l = w(() => ({
      [`btn-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (p(), M(ze, {
      class: z(["btn disabled", l.value]),
      animation: a.animation,
      width: a.width,
      cols: a.cols,
      tag: a.tag
    }, null, 8, ["class", "animation", "width", "cols", "tag"]));
  }
}), ic = /* @__PURE__ */ x({
  __name: "BPlaceholderCard",
  props: {
    noHeader: { type: [String, Boolean], default: !1 },
    headerWidth: { default: 100 },
    headerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    noFooter: { type: [String, Boolean], default: !1 },
    footerWidth: { default: 100 },
    footerVariant: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    animation: { default: void 0 },
    size: { default: "md" },
    variant: { default: void 0 },
    noButton: { type: [String, Boolean], default: !1 },
    imgBottom: { type: [String, Boolean], default: !1 },
    imgSrc: { default: void 0 },
    imgBlankColor: { default: "#868e96" },
    imgHeight: { default: 100 },
    noImg: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.noButton), a = u(() => t.noHeader), o = u(() => t.noFooter), n = u(() => t.noImg), s = w(() => ({
      width: t.footerWidth,
      animation: t.footerAnimation,
      size: l.value ? t.footerSize : void 0,
      variant: t.footerVariant
    })), r = w(() => ({
      animation: t.animation,
      size: t.size,
      variant: t.variant
    }));
    return (i, d) => (p(), M(fn, { "img-bottom": i.imgBottom }, za({
      default: D(() => [
        A(i.$slots, "default", {}, () => [
          be(ze, le({ cols: "7" }, r.value), null, 16),
          be(ze, le({ cols: "4" }, r.value), null, 16),
          be(ze, le({ cols: "4" }, r.value), null, 16),
          be(ze, le({ cols: "6" }, r.value), null, 16),
          be(ze, le({ cols: "8" }, r.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      g(n) ? void 0 : {
        name: "img",
        fn: D(() => [
          A(i.$slots, "img", {}, () => [
            be(na, {
              blank: !i.imgSrc,
              "blank-color": i.imgBlankColor,
              height: i.imgSrc ? void 0 : i.imgHeight,
              src: i.imgSrc,
              top: !i.imgBottom,
              bottom: i.imgBottom
            }, null, 8, ["blank", "blank-color", "height", "src", "top", "bottom"])
          ])
        ]),
        key: "0"
      },
      g(a) ? void 0 : {
        name: "header",
        fn: D(() => [
          A(i.$slots, "header", {}, () => [
            be(ze, {
              width: i.headerWidth,
              variant: i.headerVariant,
              animation: i.headerAnimation,
              size: i.headerSize
            }, null, 8, ["width", "variant", "animation", "size"])
          ])
        ]),
        key: "1"
      },
      g(o) ? void 0 : {
        name: "footer",
        fn: D(() => [
          A(i.$slots, "footer", {}, () => [
            g(l) ? (p(), M(ze, Ve(le({ key: 1 }, s.value)), null, 16)) : (p(), M(Vn, Ve(le({ key: 0 }, s.value)), null, 16))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), sl = /* @__PURE__ */ x({
  __name: "BTableSimple",
  props: {
    bordered: { type: [String, Boolean], default: !1 },
    borderless: { type: [String, Boolean], default: !1 },
    borderVariant: { default: null },
    captionTop: { type: [String, Boolean], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    hover: { type: [String, Boolean], default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    stripedColumns: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tableClass: { default: void 0 },
    tableVariant: { default: null },
    stickyHeader: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.captionTop), a = u(() => t.borderless), o = u(() => t.bordered), n = u(() => t.dark), s = u(() => t.hover), r = u(() => t.small), i = u(() => t.striped), d = u(() => t.stickyHeader), y = u(() => t.stripedColumns), b = w(() => [
      t.tableClass,
      "table",
      "b-table",
      {
        "table-bordered": o.value,
        "table-borderless": a.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== null,
        "caption-top": l.value,
        "table-dark": n.value,
        "table-hover": s.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": i.value,
        "table-sm": r.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== null,
        "table-striped-columns": y.value
      }
    ]), c = w(() => ({
      "table-responsive": t.responsive === !0,
      [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
      "b-table-sticky-header": d.value
    }));
    return (h, S) => h.responsive ? (p(), P("div", {
      key: 1,
      class: z(c.value)
    }, [
      Z("table", {
        class: z(b.value)
      }, [
        A(h.$slots, "default")
      ], 2)
    ], 2)) : (p(), P("table", {
      key: 0,
      class: z(b.value)
    }, [
      A(h.$slots, "default")
    ], 2));
  }
}), uc = /* @__PURE__ */ x({
  __name: "BPlaceholderTable",
  props: {
    rows: { default: 3 },
    columns: { default: 5 },
    cellWidth: { default: 100 },
    size: { default: "md" },
    animation: { default: void 0 },
    variant: { default: void 0 },
    headerColumns: { default: void 0 },
    hideHeader: { type: [String, Boolean], default: !1 },
    headerCellWidth: { default: 100 },
    headerSize: { default: "md" },
    headerAnimation: { default: void 0 },
    headerVariant: { default: void 0 },
    footerColumns: { default: void 0 },
    showFooter: { type: [String, Boolean], default: !1 },
    footerCellWidth: { default: 100 },
    footerSize: { default: "md" },
    footerAnimation: { default: void 0 },
    footerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, l = Be(() => t.columns), a = Be(() => t.rows), o = N(() => t.headerColumns ?? NaN), n = N(() => t.footerColumns ?? NaN), s = Be(o), r = Be(n), i = N(() => l.value || 5), d = N(() => a.value || 3), y = N(
      () => t.headerColumns === void 0 ? i.value : s.value
    ), b = N(
      () => t.footerColumns === void 0 ? i.value : r.value
    ), c = u(() => t.hideHeader), h = u(() => t.showFooter);
    return (S, B) => (p(), M(sl, null, {
      default: D(() => [
        g(c) ? K("", !0) : A(S.$slots, "thead", { key: 0 }, () => [
          Z("thead", null, [
            Z("tr", null, [
              (p(!0), P(ve, null, he(y.value, (F, C) => (p(), P("th", { key: C }, [
                be(ze, {
                  size: S.headerSize,
                  variant: S.headerVariant,
                  animation: S.headerAnimation,
                  width: S.headerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]),
        A(S.$slots, "default", {}, () => [
          Z("tbody", null, [
            (p(!0), P(ve, null, he(d.value, (F, C) => (p(), P("tr", { key: C }, [
              (p(!0), P(ve, null, he(i.value, (V, T) => (p(), P("td", { key: T }, [
                be(ze, {
                  size: S.size,
                  variant: S.variant,
                  animation: S.animation,
                  width: S.cellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ]))), 128))
          ])
        ]),
        g(h) ? A(S.$slots, "tfoot", { key: 1 }, () => [
          Z("tfoot", null, [
            Z("tr", null, [
              (p(!0), P(ve, null, he(b.value, (F, C) => (p(), P("th", { key: C }, [
                be(ze, {
                  size: S.footerSize,
                  variant: S.footerVariant,
                  animation: S.footerAnimation,
                  width: S.footerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]) : K("", !0)
      ]),
      _: 3
    }));
  }
}), dc = /* @__PURE__ */ x({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => t.loading);
    return (a, o) => g(l) ? A(a.$slots, "loading", { key: 0 }) : A(a.$slots, "default", { key: 1 });
  }
}), cc = ["aria-valuenow", "aria-valuemax"], An = /* @__PURE__ */ x({
  __name: "BProgressBar",
  props: {
    animated: { type: [String, Boolean], default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: [String, Boolean], default: !1 },
    showValue: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    value: { default: 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, l = Le(vo, null), a = u(() => t.animated), o = u(() => t.showProgress), n = u(() => t.showValue), s = u(() => t.striped), r = qe(t), i = w(() => [
      r.value,
      {
        "progress-bar-animated": a.value || (l == null ? void 0 : l.animated.value),
        "progress-bar-striped": s.value || (l == null ? void 0 : l.striped.value) || a.value || (l == null ? void 0 : l.animated.value)
      }
    ]), d = Be(() => t.precision), y = Be(() => t.value), b = Be(N(() => t.max ?? NaN)), c = Be(N(() => (l == null ? void 0 : l.max.value) ?? NaN)), h = w(
      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || l != null && l.showValue.value ? y.value.toFixed(d.value) : o.value || l != null && l.showProgress.value ? (y.value * 100 / (b.value || 100)).toFixed(d.value) : t.label !== void 0 ? t.label : ""
    ), S = w(
      () => c.value ? `${y.value * 100 / c.value}%` : b.value ? `${y.value * 100 / b.value}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return (B, F) => (p(), P("div", {
      class: z(["progress-bar", i.value]),
      role: "progressbar",
      "aria-valuenow": B.value,
      "aria-valuemin": "0",
      "aria-valuemax": B.max,
      style: xe({ width: S.value })
    }, [
      A(B.$slots, "default", {}, () => [
        ie(J(h.value), 1)
      ])
    ], 14, cc));
  }
}), On = /* @__PURE__ */ x({
  __name: "BProgress",
  props: {
    height: { default: void 0 },
    animated: { type: [String, Boolean], default: !1 },
    max: { default: 100 },
    precision: { default: 0 },
    showProgress: { type: [String, Boolean], default: !1 },
    showValue: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    value: { default: 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, l = u(() => t.animated), a = u(() => t.showProgress), o = u(() => t.showValue), n = u(() => t.striped);
    return Ue(vo, {
      animated: l,
      max: N(() => t.max),
      showProgress: a,
      showValue: o,
      striped: n
    }), (s, r) => (p(), P("div", {
      class: "progress",
      style: xe({ height: s.height })
    }, [
      A(s.$slots, "default", {}, () => [
        be(An, {
          animated: s.animated,
          max: s.max,
          precision: s.precision,
          "show-progress": s.showProgress,
          "show-value": s.showValue,
          striped: s.striped,
          value: s.value,
          variant: s.variant,
          "text-variant": s.textVariant,
          "bg-variant": s.bgVariant
        }, null, 8, ["animated", "max", "precision", "show-progress", "show-value", "striped", "value", "variant", "text-variant", "bg-variant"])
      ])
    ], 4));
  }
}), Ul = ua("cols", [""], { type: [String, Number], default: null }), fc = x({
  name: "BRow",
  slots: Object,
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...Ul
  },
  setup(e) {
    const t = u(() => e.noGutters), l = Mt(() => e.alignH), a = w(() => io(e, Ul, "cols", "row-cols"));
    return {
      computedClasses: w(() => [
        a.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [l.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function vc(e, t, l, a, o, n) {
  return p(), M(ne(e.tag), {
    class: z(["row", e.computedClasses])
  }, {
    default: D(() => [
      A(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const pc = /* @__PURE__ */ ma(fc, [["render", vc]]), mc = ["TD", "TH", "TR"], gc = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Ut = (e) => {
  if (!e || !e.target)
    return !1;
  const t = e.target;
  if ("disabled" in t && t.disabled || mc.indexOf(t.tagName) !== -1)
    return !1;
  if (cl(".dropdown-menu", t))
    return !0;
  const l = t.tagName === "LABEL" ? t : cl("label", t);
  if (l) {
    const a = Ma(l, "for"), o = a ? ks(a) : so("input, select, textarea", l);
    if (o && !o.disabled)
      return !0;
  }
  return ro(t, gc);
}, yc = ["title", "abbr", "onClick"], bc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, hc = { key: 1 }, Bc = { key: 0 }, Sc = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"], wc = {
  key: 0,
  class: "b-table-stacked-label"
}, Cc = ["colspan"], kc = {
  key: 1,
  class: "b-table-empty-slot"
}, $c = ["colspan"], _c = { key: 2 }, Tc = { key: 0 }, Vc = ["title", "abbr", "onClick"], Ac = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, Oc = { key: 1 }, Ec = { key: 2 }, Fc = { key: 3 }, En = /* @__PURE__ */ x({
  __name: "BTableLite",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    fields: { default: () => [] },
    footClone: { type: [String, Boolean], default: !1 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: !1 },
    variant: { default: void 0 },
    showEmpty: { type: [String, Boolean], default: !1 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" },
    fieldColumnClass: { type: Function, default: void 0 },
    tbodyTrClass: { type: Function, default: void 0 },
    virtualFields: { default: 0 },
    bordered: { type: [String, Boolean], default: !1 },
    borderless: { type: [String, Boolean], default: !1 },
    borderVariant: { default: void 0 },
    captionTop: { type: [String, Boolean], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    hover: { type: [String, Boolean], default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    stripedColumns: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tableClass: { default: void 0 },
    stickyHeader: { type: [String, Boolean], default: !1 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
  setup(e, { emit: t }) {
    const l = e, a = u(() => l.footClone), o = u(() => l.labelStacked), n = u(() => l.showEmpty), s = Be(() => l.virtualFields), r = w(() => [
      l.tableClass,
      {
        [`align-${l.align}`]: l.align !== void 0
      }
    ]), i = w(() => b(l.fields, l.items)), d = N(() => i.value.length + s.value), y = (f) => typeof f == "string" ? il(f) : f.label !== void 0 ? f.label : typeof f.key == "string" ? il(f.key) : f.key, b = (f, _) => {
      const L = [];
      return !(f != null && f.length) && (_ != null && _.length) ? (Object.keys(_[0]).forEach((v) => L.push({ key: v, label: rl(v) })), L) : (Array.isArray(f) && f.forEach((v) => {
        typeof v == "string" ? L.push({ key: v, label: rl(v) }) : Sa(v) && v.key && typeof v.key == "string" && L.push({ ...v });
      }), L);
    }, c = (f, _, L) => {
      const v = fl(f, _);
      return L && typeof L == "function" ? L(v, _, f) : v;
    }, h = (f, _) => c(f, _.key, _.formatter), S = (f, _, L = !1) => {
      const v = typeof f == "string" ? f : f.key;
      t("head-clicked", v, f, _, L);
    }, B = (f, _, L) => {
      t("row-clicked", f, _, L);
    }, F = (f, _, L) => t("row-dbl-clicked", f, _, L), C = (f, _, L) => t("row-hovered", f, _, L), V = (f, _, L) => t("row-unhovered", f, _, L), T = (f) => {
      f._showDetails = !f._showDetails;
    }, $ = (f) => [
      f.class,
      f.thClass,
      {
        [`table-${f.variant}`]: f.variant !== null,
        "b-table-sticky-column": f.stickyColumn
      },
      ...l.fieldColumnClass ? l.fieldColumnClass(f) : []
    ], m = (f, _) => [
      f.class,
      f.tdClass,
      _ != null && _._cellVariants && (_ != null && _._cellVariants[f.key]) ? `table-${_ == null ? void 0 : _._cellVariants[f.key]}` : void 0,
      {
        [`table-${f.variant}`]: f.variant !== null,
        "b-table-sticky-column": f.stickyColumn
      }
    ], k = (f, _ = "row") => {
      const L = [
        f._rowVariant ? `table-${f._rowVariant}` : null,
        f._rowVariant ? `table-${f._rowVariant}` : null
      ];
      if (l.tbodyTrClass) {
        const v = l.tbodyTrClass(f, _);
        v && L.push(...typeof v == "string" ? [v] : v);
      }
      return L;
    };
    return (f, _) => (p(), M(sl, {
      bordered: f.bordered,
      borderless: f.borderless,
      "border-variant": f.borderVariant,
      "caption-top": f.captionTop,
      dark: f.dark,
      hover: f.hover,
      responsive: f.responsive,
      striped: f.striped,
      stacked: f.stacked,
      small: f.small,
      "table-class": r.value,
      "table-variant": f.variant,
      "sticky-header": f.stickyHeader,
      "striped-columns": f.stripedColumns
    }, {
      default: D(() => {
        var L;
        return [
          Z("thead", null, [
            f.$slots["thead-top"] ? A(f.$slots, "thead-top", { key: 0 }) : K("", !0),
            Z("tr", null, [
              A(f.$slots, "thead-tr-prefix"),
              (p(!0), P(ve, null, he(i.value, (v) => (p(), P("th", le({
                key: v.key,
                scope: "col",
                class: $(v),
                title: v.headerTitle,
                abbr: v.headerAbbr,
                style: v.thStyle
              }, v.thAttr, {
                onClick: (I) => S(v, I)
              }), [
                Z("div", bc, [
                  A(f.$slots, "field-prefix", { field: v }),
                  Z("div", null, [
                    f.$slots[`head(${v.key})`] || f.$slots["head()"] ? A(f.$slots, f.$slots[`head(${v.key})`] ? `head(${v.key})` : "head()", {
                      key: 0,
                      label: v.label,
                      column: v.key,
                      field: v,
                      isFoot: !1
                    }) : (p(), P(ve, { key: 1 }, [
                      ie(J(y(v)), 1)
                    ], 64))
                  ])
                ])
              ], 16, yc))), 128))
            ]),
            f.$slots["thead-sub"] ? (p(), P("tr", hc, [
              (p(!0), P(ve, null, he(i.value, (v) => (p(), P("td", {
                key: v.key,
                scope: "col",
                class: z([v.class, v.thClass, v.variant ? `table-${v.variant}` : ""])
              }, [
                f.$slots["thead-sub"] ? A(f.$slots, "thead-sub", le({
                  key: 0,
                  items: i.value
                }, v)) : (p(), P(ve, { key: 1 }, [
                  ie(J(v.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : K("", !0)
          ]),
          Z("tbody", null, [
            !f.stacked && f.$slots["top-row"] ? (p(), P("tr", Bc, [
              A(f.$slots, "top-row")
            ])) : K("", !0),
            (p(!0), P(ve, null, he(f.items, (v, I) => (p(), P(ve, { key: I }, [
              Z("tr", {
                class: z(k(v, "row")),
                onClick: (H) => !g(Ut)(H) && B(v, I, H),
                onDblclick: (H) => !g(Ut)(H) && F(v, I, H),
                onMouseenter: (H) => !g(Ut)(H) && C(v, I, H),
                onMouseleave: (H) => !g(Ut)(H) && V(v, I, H)
              }, [
                A(f.$slots, "tbody-tr-prefix", { item: v }),
                (p(!0), P(ve, null, he(i.value, (H) => (p(), P("td", le({
                  key: H.key
                }, H.tdAttr, {
                  class: m(H, v)
                }), [
                  f.stacked && g(o) ? (p(), P("label", wc, J(y(H)), 1)) : K("", !0),
                  f.$slots[`cell(${H.key})`] || f.$slots["cell()"] ? A(f.$slots, f.$slots[`cell(${H.key})`] ? `cell(${H.key})` : "cell()", {
                    key: 1,
                    value: g(fl)(v, H.key),
                    index: I,
                    item: v,
                    field: H,
                    items: f.items,
                    toggleDetails: () => T(v),
                    detailsShowing: v._showDetails
                  }) : (p(), P(ve, { key: 2 }, [
                    ie(J(h(v, H)), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, Sc),
              v._showDetails === !0 && f.$slots["row-details"] ? (p(), P("tr", {
                key: 0,
                class: z(k(v, "row-details"))
              }, [
                Z("td", { colspan: d.value }, [
                  A(f.$slots, "row-details", {
                    item: v,
                    toggleDetails: () => T(v)
                  })
                ], 8, Cc)
              ], 2)) : K("", !0)
            ], 64))), 128)),
            A(f.$slots, "tbody-prefix", { fieldsTotal: d.value }),
            g(n) && f.items.length === 0 ? (p(), P("tr", kc, [
              Z("td", { colspan: d.value }, [
                A(f.$slots, "empty", { items: f.items }, () => [
                  ie(J(f.emptyText), 1)
                ])
              ], 8, $c)
            ])) : K("", !0),
            !f.stacked && f.$slots["bottom-row"] ? (p(), P("tr", _c, [
              A(f.$slots, "bottom-row")
            ])) : K("", !0)
          ]),
          g(a) ? (p(), P("tfoot", Tc, [
            Z("tr", null, [
              A(f.$slots, "tfoot-tr-prefix"),
              (p(!0), P(ve, null, he(i.value, (v) => (p(), P("th", le({
                key: v.key,
                scope: "col",
                class: $(v),
                title: v.headerTitle,
                abbr: v.headerAbbr,
                style: v.thStyle
              }, v.thAttr, {
                onClick: (I) => S(v, I)
              }), [
                Z("div", Ac, [
                  A(f.$slots, "field-prefix", { field: v }),
                  Z("div", null, [
                    f.$slots[`foot(${v.key})`] || f.$slots["foot()"] ? A(f.$slots, f.$slots[`foot(${v.key})`] ? `foot(${v.key})` : "foot()", {
                      key: 0,
                      label: v.label,
                      column: v.key,
                      field: v,
                      isFoot: !0
                    }) : (p(), P(ve, { key: 1 }, [
                      ie(J(y(v)), 1)
                    ], 64))
                  ])
                ])
              ], 16, Vc))), 128))
            ])
          ])) : f.$slots["custom-foot"] ? (p(), P("tfoot", Oc, [
            A(f.$slots, "custom-foot", {
              fields: i.value,
              items: f.items,
              columns: (L = i.value) == null ? void 0 : L.length
            })
          ])) : K("", !0),
          f.$slots["table-caption"] ? (p(), P("caption", Ec, [
            A(f.$slots, "table-caption")
          ])) : f.caption ? (p(), P("caption", Fc, J(f.caption), 1)) : K("", !0)
        ];
      }),
      _: 3
    }, 8, ["bordered", "borderless", "border-variant", "caption-top", "dark", "hover", "responsive", "striped", "stacked", "small", "table-class", "table-variant", "sticky-header", "striped-columns"]));
  }
}), Pc = ["colspan"], Nc = { class: "d-flex align-items-center justify-content-center gap-2" }, Lc = /* @__PURE__ */ x({
  __name: "BTable",
  props: {
    provider: { type: Function, default: void 0 },
    sortCompare: { type: Function, default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: [String, Boolean], default: !1 },
    noProviderSorting: { type: [String, Boolean], default: !1 },
    noProviderFiltering: { type: [String, Boolean], default: !1 },
    sortBy: { default: void 0 },
    sortDesc: { type: [String, Boolean], default: !1 },
    sortInternal: { type: [String, Boolean], default: !0 },
    selectable: { type: [String, Boolean], default: !1 },
    stickySelect: { type: [String, Boolean], default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    busy: { type: [String, Boolean], default: !1 },
    busyLoadingText: { default: "Loading..." },
    perPage: { default: void 0 },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    bordered: { type: [String, Boolean], default: !1 },
    borderless: { type: [String, Boolean], default: !1 },
    borderVariant: { default: void 0 },
    captionTop: { type: [String, Boolean], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    hover: { type: [String, Boolean], default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    stripedColumns: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    stickyHeader: { type: [String, Boolean], default: !1 },
    align: { default: void 0 },
    caption: { default: void 0 },
    fields: { default: () => [] },
    footClone: { type: [String, Boolean], default: !1 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: !1 },
    variant: { default: void 0 },
    showEmpty: { type: [String, Boolean], default: !1 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" },
    fieldColumnClass: { type: Function, default: void 0 },
    tbodyTrClass: { type: Function, default: void 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered", "row-selected", "row-unselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "sortBy", l, { passive: !0 }), n = Se(a, "busy", l, { passive: !0 }), s = Se(a, "sortDesc", l, { passive: !0 }), r = Oe(), i = R(null), d = u(s), y = u(() => a.sortInternal), b = u(n), c = u(() => a.noProviderPaging), h = u(() => a.noProviderSorting), S = u(() => a.noProviderFiltering), B = u(() => a.selectable), F = u(() => a.stickySelect), C = N(() => a.filter !== void 0 && a.filter !== ""), V = R(/* @__PURE__ */ new Set([])), T = N(() => V.value.size > 0), $ = w(() => a.fields.filter((j) => typeof j == "string" ? !1 : j.sortable).length > 0 || a.sortBy !== void 0), m = N(() => a.provider !== void 0), k = w(() => ({
      "b-table-sortable": $.value,
      "b-table-sort-desc": $.value && d.value === !0,
      "b-table-sort-asc": $.value && d.value === !1,
      "b-table-busy": b.value,
      "b-table-selectable": B.value,
      [`b-table-select-${a.selectMode}`]: B.value,
      "b-table-selecting user-select-none": B.value && T.value
    })), f = N(
      () => $.value && y.value === !0 || $.value && m.value || C.value
    ), _ = N(
      () => B.value && (!!a.selectHead || r.selectHead !== void 0)
    ), {
      computedItems: L,
      computedDisplayItems: v,
      updateInternalItems: I,
      filteredHandler: H,
      notifyFilteredItems: O
    } = Yr(
      a,
      {
        sortInternalBoolean: y,
        isFilterableTable: C,
        noProviderFilteringBoolean: S,
        noProviderPagingBoolean: c,
        noProviderSortingBoolean: h,
        isSortable: $,
        requireItemsMapping: f,
        sortDescBoolean: d
      },
      m,
      o
    );
    re(
      () => a.items,
      (E) => I(E)
    ), H.value = async (E) => {
      if (m.value) {
        await ue();
        return;
      }
      l("filtered", E);
    };
    const q = (E, j, U) => {
      ye(E, j, U.shiftKey, U.ctrlKey, U.metaKey), l("row-clicked", E, j, U);
    }, Q = (E, j, U, ce = !1) => {
      l("head-clicked", E, j, U, ce), X(j);
    }, X = (E) => {
      if (!$.value)
        return;
      const j = typeof E == "string" ? E : E.key, U = typeof E == "string" ? !1 : E.sortable;
      if ($.value === !0 && U === !0) {
        const ce = !d.value;
        o.value = j, s.value = ce, l("sorted", j, ce);
      }
    }, ue = async () => {
      if (!m.value || !a.provider || b.value)
        return;
      n.value = !0;
      const E = new Proxy(
        {
          currentPage: a.currentPage,
          filter: a.filter,
          sortBy: a.sortBy,
          sortDesc: a.sortDesc,
          perPage: a.perPage
        },
        {
          get: (U, ce) => ce in U ? U[ce] : void 0,
          set: () => (console.error("BTable provider context is a read-only object."), !0)
        }
      ), j = a.provider(E, I);
      if (j !== void 0) {
        if (j instanceof Promise)
          try {
            const U = await j;
            return Array.isArray(U) ? await I(U) : void 0;
          } finally {
            b.value && (n.value = !1);
          }
        try {
          return await I(j);
        } finally {
          b.value && (n.value = !1);
        }
      }
    }, ae = (E) => [
      {
        "b-table-sortable-column": $.value && E.sortable
      }
    ], me = (E, j) => {
      const U = [
        B.value && E && V.value.has(E) ? `selected table-${a.selectionVariant}` : null
      ];
      if (a.tbodyTrClass) {
        const ce = a.tbodyTrClass(E, j);
        ce && U.push(...typeof ce == "string" ? [ce] : ce);
      }
      return U;
    }, te = () => {
      const E = [{ "b-table-static-busy": L.value.length === 0 }];
      if (a.tbodyTrClass) {
        const j = a.tbodyTrClass(null, "table-busy");
        j && E.push(...typeof j == "string" ? [j] : j);
      }
      return E;
    }, de = () => {
      B.value && l("selection", Array.from(V.value));
    }, ye = (E, j, U = !1, ce = !1, Y = !1) => {
      if (B.value) {
        if (U && a.selectMode === "range" && V.value.size > 0) {
          const se = Array.from(V.value).pop(), $e = a.items.findIndex((Ce) => Ce === se), it = Math.min($e, j), De = Math.max($e, j);
          a.items.slice(it, De + 1).forEach((Ce) => {
            V.value.has(Ce) || (V.value.add(Ce), l("row-selected", Ce));
          });
        } else
          ce || Y ? V.value.has(E) ? (V.value.delete(E), l("row-unselected", E)) : a.selectMode === "range" || a.selectMode === "multi" ? (V.value.add(E), l("row-selected", E)) : (V.value.forEach((se) => {
            l("row-unselected", se);
          }), V.value.clear(), V.value.add(E), l("row-selected", E)) : (V.value.forEach((se) => {
            l("row-unselected", se);
          }), V.value.clear(), V.value.add(E), l("row-selected", E));
        de();
      }
    }, G = () => {
      if (!B.value)
        return;
      const E = V.value.size > 0 ? Array.from(V.value) : [];
      V.value = /* @__PURE__ */ new Set([...L.value]), V.value.forEach((j) => {
        E.includes(j) || l("row-selected", j);
      }), de();
    }, oe = () => {
      B.value && (V.value.forEach((E) => {
        l("row-unselected", E);
      }), V.value = /* @__PURE__ */ new Set([]), de());
    }, fe = (E) => {
      if (!B.value)
        return;
      const j = a.items[E];
      !j || V.value.has(j) || (V.value.add(j), l("row-selected", j), de());
    }, W = (E) => {
      if (!B.value)
        return;
      const j = a.items[E];
      !j || !V.value.has(j) || (V.value.delete(j), l("row-unselected", j), de());
    }, ee = async (E, j, U) => {
      if (j === U)
        return;
      const ce = (De) => a.noProvider && a.noProvider.includes(De), Y = !["currentPage", "perPage"].includes(E), se = ["currentPage", "perPage"].includes(E) && (ce("paging") || c.value === !0), $e = ["filter"].includes(E) && (ce("filtering") || S.value === !0), it = ["sortBy", "sortDesc"].includes(E) && (ce("sorting") || h.value === !0);
      se || $e || it || (await ue(), Y && O());
    };
    return re(
      () => a.filter,
      (E, j) => {
        E === j || m.value || E || l("filtered", L.value);
      }
    ), re(
      () => a.filter,
      (E, j) => ee("filter", E, j)
    ), re(
      () => a.currentPage,
      (E, j) => ee("currentPage", E, j)
    ), re(
      () => a.perPage,
      (E, j) => ee("perPage", E, j)
    ), re(
      () => a.sortBy,
      (E, j) => ee("sortBy", E, j)
    ), re(
      () => a.sortDesc,
      (E, j) => ee("sortDesc", E, j)
    ), Ze(ue), t({
      selectAllRows: G,
      clearSelected: oe,
      selectRow: fe,
      unselectRow: W,
      refresh: ue
    }), (E, j) => (p(), M(En, le({
      ref_key: "liteTable",
      ref: i
    }, a, {
      busy: g(n),
      "onUpdate:busy": j[0] || (j[0] = (U) => La(n) ? n.value = U : null),
      items: g(v),
      "table-class": k.value,
      "tbody-tr-class": me,
      "field-column-class": ae,
      "virtual-fields": g(B) ? 1 : 0,
      onHeadClicked: Q,
      onRowClicked: q
    }), za({
      "field-prefix": D((U) => [
        A(E.$slots, "sort-icon", {
          field: U.field,
          sortBy: g(o),
          selected: U.field.key === g(o),
          isDesc: g(d),
          direction: g(d) ? "desc" : "asc"
        }, () => [
          $.value && U.field.sortable ? (p(), P("span", {
            key: 0,
            class: z(["b-table-sort-icon", {
              sorted: U.field.key === g(o),
              [`sorted-${g(d) ? "desc" : "asc"}`]: U.field.key === g(o)
            }])
          }, null, 2)) : K("", !0)
        ])
      ]),
      "thead-tr-prefix": D(() => [
        _.value ? (p(), P("th", {
          key: 0,
          class: z(["b-table-selection-column", {
            "b-table-sticky-column": g(F)
          }])
        }, [
          A(E.$slots, "select-head", {}, () => [
            ie(J(typeof E.selectHead == "boolean" ? "Selected" : E.selectHead), 1)
          ])
        ], 2)) : K("", !0)
      ]),
      "tbody-tr-prefix": D((U) => [
        _.value ? (p(), P("td", {
          key: 0,
          class: z(["b-table-selection-column", {
            "b-table-sticky-column": g(F)
          }])
        }, [
          A(E.$slots, "select-cell", {}, () => [
            Z("span", {
              class: z(["b-table-selection-icon", V.value.has(U.item) ? `text-${a.selectionVariant} selected` : ""])
            }, "ð¹", 2)
          ])
        ], 2)) : K("", !0)
      ]),
      "tbody-prefix": D((U) => [
        g(b) ? (p(), P("tr", {
          key: 0,
          class: z(["b-table-busy-slot", te()])
        }, [
          Z("td", {
            colspan: U.fieldsTotal
          }, [
            A(E.$slots, "table-busy", {}, () => [
              Z("div", Nc, [
                be(pa, { class: "align-middle" }),
                Z("strong", null, J(E.busyLoadingText), 1)
              ])
            ])
          ], 8, Pc)
        ], 2)) : K("", !0)
      ]),
      _: 2
    }, [
      he(E.$slots, (U, ce) => ({
        name: ce,
        fn: D((Y) => [
          A(E.$slots, ce, Ve(Pe(Y)))
        ])
      }))
    ]), 1040, ["busy", "items", "table-class", "virtual-fields"]));
  }
}), Ic = /* @__PURE__ */ x({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = w(() => ({
      [`thead-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (p(), P("tbody", {
      class: z(l.value)
    }, [
      A(a.$slots, "default")
    ], 2));
  }
}), Hc = ["scope", "colspan", "rowspan", "data-label"], zc = { key: 0 }, xc = /* @__PURE__ */ x({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => t.stickyColumn), a = w(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": l.value,
      "table-b-table-default": l.value && t.variant === null
    })), o = N(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, s) => (p(), P("td", {
      scope: o.value,
      class: z(a.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading ? (p(), P("div", zc, [
        A(n.$slots, "default")
      ])) : A(n.$slots, "default", { key: 1 })
    ], 10, Hc));
  }
}), Rc = /* @__PURE__ */ x({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = w(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (p(), P("tfoot", {
      class: z(l.value)
    }, [
      A(a.$slots, "default")
    ], 2));
  }
}), Mc = ["scope", "colspan", "rowspan", "data-label"], Dc = { key: 0 }, jc = /* @__PURE__ */ x({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => t.stickyColumn), a = w(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": l.value,
      "table-b-table-default": l.value && t.variant === null
    })), o = N(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, s) => (p(), P("th", {
      scope: o.value,
      class: z(a.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading !== void 0 ? (p(), P("div", Dc, [
        A(n.$slots, "default")
      ])) : A(n.$slots, "default", { key: 1 })
    ], 10, Mc));
  }
}), qc = /* @__PURE__ */ x({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = w(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (p(), P("thead", {
      class: z(l.value)
    }, [
      A(a.$slots, "default")
    ], 2));
  }
}), Gc = /* @__PURE__ */ x({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = w(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (p(), P("tr", {
      class: z(l.value)
    }, [
      A(a.$slots, "default")
    ], 2));
  }
}), Wc = /* @__PURE__ */ x({
  __name: "BTab",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    buttonId: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: void 0 },
    lazyOnce: { type: [String, Boolean], default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, l = Le(fo, null), a = u(() => t.active), o = u(() => t.disabled), n = u(
      w(() => t.lazyOnce !== void 0 ? t.lazyOnce : t.lazy)
    ), s = R(!1), r = N(() => !!(l != null && l.lazy.value || n.value)), i = N(() => t.lazyOnce !== void 0), d = N(() => a.value && !o.value), y = w(() => {
      const h = r.value && i.value && s.value;
      return d.value || !r.value || h;
    }), b = R(a.value);
    re(a, (h) => {
      setTimeout(() => {
        b.value = h;
      }, 0);
    });
    const c = w(() => ({
      active: a.value,
      show: b.value,
      "card-body": (l == null ? void 0 : l.card.value) && t.noBody === !1
    }));
    return re(y, (h) => {
      h && !s.value && (s.value = !0);
    }), (h, S) => (p(), M(ne(h.tag), {
      id: h.id,
      class: z(["tab-pane", c.value]),
      role: "tabpanel",
      "aria-labelledby": h.buttonId
    }, {
      default: D(() => [
        y.value ? A(h.$slots, "default", { key: 0 }) : K("", !0)
      ]),
      _: 3
    }, 8, ["id", "class", "aria-labelledby"]));
  }
}), Uc = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"], Xc = /* @__PURE__ */ x({
  __name: "BTabs",
  props: {
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    contentClass: { default: void 0 },
    card: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    fill: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    justified: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    navClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: [String, Boolean], default: !1 },
    noNavStyle: { type: [String, Boolean], default: !1 },
    pills: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    vertical: { type: [String, Boolean], default: !1 },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const l = e, a = Se(l, "modelValue", t), o = Oe(), n = u(() => l.card), s = u(() => l.end), r = u(() => l.fill), i = u(() => l.justified), d = u(() => l.lazy), y = u(() => l.noFade), b = u(() => l.noNavStyle), c = u(() => l.pills), h = u(() => l.small), S = u(() => l.vertical), B = R(a.value), F = R(""), C = w({
      get: () => B.value,
      set: (v) => {
        B.value = v, T.value.length > 0 && v >= 0 && v < T.value.length ? F.value = T.value[v].buttonId : F.value = "", a.value = v;
      }
    }), V = R([]);
    re(
      () => {
        var v;
        return (v = o.default) == null ? void 0 : v.call(o);
      },
      () => {
        V.value = o.default === void 0 ? [] : Ca(o.default, "BTab").map((v, I) => {
          v.props || (v.props = {});
          const H = v.props["button-id"] || mt("tab"), O = v.props.id || mt(), q = v.props["title-item-class"], Q = v.props["title-link-attributes"];
          return {
            buttonId: H,
            contentId: O,
            disabled: v.props.disabled === "" || v.props.disabled === !0,
            target: `#${O}`,
            title: v.props.title,
            titleItemClass: q,
            titleLinkAttributes: Q,
            onClick: v.props.onClick,
            tab: v,
            tabComponent: () => Ca(o.default, "BTab")[I]
          };
        });
      },
      { immediate: !0 }
    );
    const T = w(
      () => V.value.map((v, I) => {
        const { tab: H } = v;
        H.props || (H.props = {});
        const O = C.value > -1 ? I === C.value : H.props.active === "";
        return {
          ...v,
          active: O,
          navItemClasses: [
            {
              active: O,
              disabled: H.props.disabled === "" || H.props.disabled === !0
            },
            O && l.activeNavItemClass ? l.activeNavItemClass : null,
            H.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !y.value
            },
            O && l.activeTabClass ? l.activeTabClass : null
          ]
        };
      })
    ), $ = N(() => !(T != null && T.value && T.value.length > 0)), m = w(() => ({
      "d-flex": S.value,
      "align-items-start": S.value
    })), k = Mt(() => l.align), f = w(() => ({
      "nav-pills": c.value,
      "flex-column me-3": S.value,
      [k.value]: l.align !== void 0,
      "nav-fill": r.value,
      "card-header-tabs": n.value,
      "nav-justified": i.value,
      "nav-tabs": !b.value && !c.value,
      small: h.value
    })), _ = (v) => {
      let I = !1;
      if (v !== void 0 && v > -1 && v < T.value.length && !T.value[v].disabled && (C.value < 0 || T.value[v].buttonId !== F.value)) {
        const H = new ot("activate-tab", { cancelable: !0 });
        t("activate-tab", v, C.value, H), H.defaultPrevented || (C.value = v, I = !0);
      }
      return !I && a.value !== C.value && (a.value = C.value), I;
    }, L = (v, I) => {
      var H;
      _(I), I >= 0 && !T.value[I].disabled && ((H = T.value[I]) != null && H.onClick) && typeof T.value[I].onClick == "function" && T.value[I].onClick(v);
    };
    return _(B.value), re(a, (v, I) => {
      if (v === I)
        return;
      if (v = Math.max(v, -1), I = Math.max(I, -1), T.value.length <= 0) {
        C.value = -1;
        return;
      }
      const H = v > I;
      let O = v;
      const q = T.value.length - 1;
      for (; O >= 0 && O <= q && T.value[O].disabled; )
        O += H ? 1 : -1;
      if (O < 0) {
        _(0);
        return;
      }
      if (O >= T.value.length) {
        _(T.value.length - 1);
        return;
      }
      _(O);
    }), re(T, () => {
      let v = T.value.map((I) => I.active && !I.disabled).lastIndexOf(!0);
      v < 0 && (C.value >= T.value.length ? v = T.value.map((I) => !I.disabled).lastIndexOf(!0) : T.value[C.value] && !T.value[C.value].disabled && (v = C.value)), v < 0 && (v = T.value.map((I) => !I.disabled).indexOf(!0)), T.value.forEach((I, H) => {
        I.active = H === v;
      }), _(v);
    }), Ze(() => {
      if (C.value < 0 && T.value.length > 0 && !T.value.some((v) => v.active)) {
        const v = T.value.map((I) => !I.disabled).indexOf(!0);
        _(v >= 0 ? v : -1);
      }
    }), Ue(fo, {
      lazy: d,
      card: n
    }), (v, I) => (p(), M(ne(v.tag), {
      id: v.id,
      class: z(["tabs", m.value])
    }, {
      default: D(() => [
        g(s) ? (p(), P("div", {
          key: 0,
          class: z(["tab-content", v.contentClass])
        }, [
          (p(!0), P(ve, null, he(T.value, ({ tabComponent: H, contentId: O, tabClasses: q, active: Q }, X) => (p(), M(ne(H()), {
            id: O,
            key: X,
            class: z(q),
            active: Q
          }, null, 8, ["id", "class", "active"]))), 128)),
          $.value ? (p(), P("div", {
            key: "bv-empty-tab",
            class: z(["tab-pane active", { "card-body": g(n) }])
          }, [
            A(v.$slots, "empty")
          ], 2)) : K("", !0)
        ], 2)) : K("", !0),
        Z("div", {
          class: z([v.navWrapperClass, { "card-header": g(n), "ms-auto": v.vertical && g(s) }])
        }, [
          Z("ul", {
            class: z(["nav", [f.value, v.navClass]]),
            role: "tablist"
          }, [
            A(v.$slots, "tabs-start"),
            (p(!0), P(ve, null, he(T.value, ({ tab: H, buttonId: O, contentId: q, navItemClasses: Q, active: X, target: ue }, ae) => {
              var me, te, de;
              return p(), P("li", {
                key: ae,
                class: z(["nav-item", (me = H == null ? void 0 : H.props) == null ? void 0 : me["title-item-class"]]),
                role: "presentation"
              }, [
                Z("button", le({
                  id: O,
                  class: ["nav-link", Q],
                  "data-bs-toggle": "tab",
                  "data-bs-target": ue,
                  role: "tab",
                  "aria-controls": q,
                  "aria-selected": X
                }, (te = H == null ? void 0 : H.props) == null ? void 0 : te["title-link-attributes"], {
                  onClick: Ha((ye) => L(ye, ae), ["stop", "prevent"])
                }), [
                  H.children && H.children.title ? (p(), M(ne(H.children.title), { key: 0 })) : (p(), P(ve, { key: 1 }, [
                    ie(J((de = H == null ? void 0 : H.props) == null ? void 0 : de.title), 1)
                  ], 64))
                ], 16, Uc)
              ], 2);
            }), 128)),
            A(v.$slots, "tabs-end")
          ], 2)
        ], 2),
        g(s) ? K("", !0) : (p(), P("div", {
          key: 1,
          class: z(["tab-content", v.contentClass])
        }, [
          (p(!0), P(ve, null, he(T.value, ({ tabComponent: H, contentId: O, tabClasses: q, active: Q, buttonId: X }, ue) => (p(), M(ne(H()), {
            id: O,
            key: ue,
            class: z(q),
            active: Q,
            "button-id": X
          }, null, 8, ["id", "class", "active", "button-id"]))), 128)),
          $.value ? (p(), P("div", {
            key: "bv-empty-tab",
            class: z(["tab-pane active", { "card-body": g(n) }])
          }, [
            A(v.$slots, "empty")
          ], 2)) : K("", !0)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Kc = ["id", "role", "aria-live", "aria-atomic"], Jc = { class: "me-auto" }, Fn = /* @__PURE__ */ x({
  __name: "BToast",
  props: {
    delay: { default: 5e3 },
    bodyClass: { default: void 0 },
    body: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "div" },
    animation: { type: [String, Boolean], default: !0 },
    id: { default: void 0 },
    isStatus: { type: [String, Boolean], default: !1 },
    autoHide: { type: [String, Boolean], default: !0 },
    noCloseButton: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    noHoverPause: { type: [String, Boolean], default: !1 },
    solid: { type: [String, Boolean], default: !1 },
    title: { default: void 0 },
    modelValue: { type: [Boolean, Number], default: !1 },
    toastClass: { default: void 0 },
    showOnPause: { type: [String, Boolean], default: !0 },
    interval: { default: 1e3 },
    progressProps: { default: void 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: void 0 },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean] }
  },
  emits: ["destroyed", "close", "closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = R(null), n = Za(o), s = Se(a, "modelValue", l), { computedLink: r, computedLinkProps: i } = ht(a);
    u(() => a.animation);
    const d = u(() => a.isStatus);
    u(() => a.autoHide);
    const y = u(() => a.noCloseButton), b = u(() => a.noFade), c = u(() => a.noHoverPause), h = u(() => a.showOnPause), S = Be(() => a.interval);
    u(() => a.solid);
    const B = qe(a), F = N(() => typeof s.value == "boolean" ? 0 : s.value), {
      isActive: C,
      pause: V,
      restart: T,
      resume: $,
      stop: m,
      isPaused: k,
      value: f
    } = Wo(F, S, {
      immediate: typeof s.value == "number"
    });
    Ot(() => {
      l("close-countdown", f.value);
    });
    const _ = N(() => r.value ? tt : "div"), L = N(
      () => typeof s.value == "boolean" ? s.value : C.value || h.value && k.value
    );
    re(C, (O) => {
      O === !1 && k.value === !1 && l("destroyed");
    });
    const v = w(() => [
      B.value,
      {
        show: L.value
      }
    ]), I = () => {
      l("close"), typeof s.value == "boolean" ? s.value = !1 : (s.value = 0, m()), l("closed");
    }, H = () => {
      c.value || V();
    };
    return re(n, (O) => {
      if (O) {
        H();
        return;
      }
      $();
    }), Ia(m), t({
      pause: V,
      resume: $,
      restart: T,
      stop: m
    }), (O, q) => (p(), M(Pt, { "no-fade": g(b) }, {
      default: D(() => [
        L.value ? (p(), P("div", {
          key: 0,
          id: O.id,
          ref_key: "element",
          ref: o,
          class: z(["toast", [O.toastClass, v.value]]),
          tabindex: "0",
          role: L.value ? g(d) ? "status" : "alert" : void 0,
          "aria-live": L.value ? g(d) ? "polite" : "assertive" : void 0,
          "aria-atomic": L.value ? !0 : void 0
        }, [
          O.$slots.title || O.title ? (p(), M(ne(O.headerTag), {
            key: 0,
            class: "toast-header"
          }, {
            default: D(() => [
              A(O.$slots, "title", { hide: I }, () => [
                Z("strong", Jc, J(O.title), 1)
              ]),
              g(y) ? K("", !0) : (p(), M(Nt, {
                key: 0,
                onClick: I
              }))
            ]),
            _: 3
          })) : K("", !0),
          O.$slots.default || O.body ? (p(), M(ne(_.value), le({
            key: 1,
            class: ["toast-body", O.bodyClass],
            style: { display: "block" }
          }, g(i), {
            onClick: q[0] || (q[0] = (Q) => g(r) ? I : () => {
            })
          }), {
            default: D(() => [
              A(O.$slots, "default", { hide: I }, () => [
                ie(J(O.body), 1)
              ])
            ]),
            _: 3
          }, 16, ["class"])) : K("", !0),
          typeof g(s) == "number" && O.progressProps !== void 0 ? (p(), M(On, {
            key: 2,
            animated: O.progressProps.animated,
            precision: O.progressProps.precision,
            "show-progress": O.progressProps.showProgress,
            "show-value": O.progressProps.showValue,
            striped: O.progressProps.striped,
            variant: O.progressProps.variant,
            max: g(s),
            value: g(f),
            height: "4px"
          }, null, 8, ["animated", "precision", "show-progress", "show-value", "striped", "variant", "max", "value"])) : K("", !0)
        ], 10, Kc)) : K("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), Yc = { id: "__BVID__toaster-container" }, Zc = /* @__PURE__ */ x({
  __name: "BToaster",
  props: {
    teleportTo: { default: "body" },
    teleportDisabled: { type: [String, Boolean], default: !1 }
  },
  setup(e, { expose: t }) {
    const l = e, a = u(() => l.teleportDisabled), o = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, { hide: n, toasts: s } = tn(), r = (i) => uo(i, ["value", "self", "pos"]);
    return t({
      hide: n
    }), (i, d) => (p(), M(sa, {
      to: i.teleportTo,
      disabled: g(a)
    }, [
      Z("div", Yc, [
        (p(), P(ve, null, he(o, (y, b) => Z("div", {
          key: b,
          class: z([y, "toast-container position-fixed p-3"])
        }, [
          (p(!0), P(ve, null, he(g(s).filter((c) => c.pos === b), (c) => (p(), M(Fn, le({
            key: c.self,
            modelValue: c.value,
            "onUpdate:modelValue": (h) => c.value = h
          }, r(c), {
            onDestroyed: (h) => g(n)(c.self)
          }), null, 16, ["modelValue", "onUpdate:modelValue", "onDestroyed"]))), 128))
        ], 2)), 64))
      ])
    ], 8, ["to", "disabled"]));
  }
}), Qc = /* @__PURE__ */ x({
  __name: "BTooltip",
  props: {
    modelValue: { type: [String, Boolean], default: void 0 },
    container: { default: void 0 },
    target: { default: void 0 },
    reference: { default: void 0 },
    content: { default: void 0 },
    id: { default: void 0 },
    title: { default: void 0 },
    delay: { default: void 0 },
    click: { type: [String, Boolean], default: void 0 },
    manual: { type: [String, Boolean], default: void 0 },
    variant: { default: void 0 },
    offset: { default: void 0 },
    customClass: { default: void 0 },
    placement: { default: void 0 },
    strategy: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    noFlip: { type: [String, Boolean], default: void 0 },
    noShift: { type: [String, Boolean], default: void 0 },
    noFade: { type: [String, Boolean], default: void 0 },
    noAutoClose: { type: [String, Boolean], default: void 0 },
    hide: { type: [String, Boolean] },
    realtime: { type: [String, Boolean], default: void 0 },
    inline: { type: [String, Boolean], default: void 0 },
    html: { type: [String, Boolean], default: void 0 },
    noninteractive: { type: [String, Boolean], default: !0 }
  },
  setup(e, { expose: t }) {
    var a, o, n;
    const l = R(null);
    return t({
      hide: (a = l.value) == null ? void 0 : a.hide,
      show: (o = l.value) == null ? void 0 : o.show,
      toggle: (n = l.value) == null ? void 0 : n.toggle
    }), (s, r) => (p(), M(tl, le({
      ref_key: "popover",
      ref: l,
      tooltip: ""
    }, s.$props), za({ _: 2 }, [
      he(s.$slots, (i, d) => ({
        name: d,
        fn: D((y) => [
          A(s.$slots, d, Ve(Pe(y)))
        ])
      }))
    ]), 1040));
  }
}), Xl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: ni,
  BAccordionItem: ui,
  BAlert: vi,
  BAvatar: bi,
  BAvatarGroup: hi,
  BBadge: Bi,
  BBreadcrumb: Ci,
  BBreadcrumbItem: on,
  BButton: ut,
  BButtonGroup: ki,
  BButtonToolbar: _i,
  BCard: fn,
  BCardBody: dn,
  BCardFooter: cn,
  BCardGroup: Oi,
  BCardHeader: sn,
  BCardImg: na,
  BCardSubtitle: un,
  BCardText: Ei,
  BCardTitle: rn,
  BCarousel: xi,
  BCarouselSlide: qi,
  BCloseButton: Nt,
  BCol: Lt,
  BCollapse: ln,
  BContainer: Ui,
  BDropdown: vn,
  BDropdownDivider: Yi,
  BDropdownForm: eu,
  BDropdownGroup: lu,
  BDropdownHeader: nu,
  BDropdownItem: ru,
  BDropdownItemButton: du,
  BDropdownText: vu,
  BForm: pn,
  BFormCheckbox: mn,
  BFormCheckboxGroup: Cu,
  BFormFile: _u,
  BFormFloatingLabel: yu,
  BFormGroup: Nu,
  BFormInput: Iu,
  BFormInvalidFeedback: Va,
  BFormRadio: yn,
  BFormRadioGroup: Du,
  BFormRow: Jt,
  BFormSelect: Wu,
  BFormSelectOption: ll,
  BFormSelectOptionGroup: bn,
  BFormSpinbutton: Yu,
  BFormTag: Cn,
  BFormTags: fd,
  BFormText: Aa,
  BFormTextarea: pd,
  BFormValidFeedback: Oa,
  BImg: al,
  BInputGroup: Sd,
  BInputGroupAddon: ol,
  BInputGroupAppend: wd,
  BInputGroupPrepend: Cd,
  BInputGroupText: kn,
  BLink: tt,
  BListGroup: kd,
  BListGroupItem: $d,
  BModal: Ad,
  BNav: Od,
  BNavForm: Fd,
  BNavItem: Nd,
  BNavItemDropdown: Id,
  BNavText: zd,
  BNavbar: xd,
  BNavbarBrand: Rd,
  BNavbarNav: Md,
  BNavbarToggle: Kd,
  BOffcanvas: Zd,
  BOverlay: nl,
  BPagination: rc,
  BPlaceholder: ze,
  BPlaceholderButton: Vn,
  BPlaceholderCard: ic,
  BPlaceholderTable: uc,
  BPlaceholderWrapper: dc,
  BPopover: tl,
  BProgress: On,
  BProgressBar: An,
  BRow: pc,
  BSpinner: pa,
  BTab: Wc,
  BTable: Lc,
  BTableLite: En,
  BTableSimple: sl,
  BTabs: Xc,
  BTbody: Ic,
  BTd: xc,
  BTfoot: Rc,
  BTh: jc,
  BThead: qc,
  BToast: Fn,
  BToaster: Zc,
  BTooltip: Qc,
  BTr: Gc,
  BTransition: Pt
}, Symbol.toStringTag, { value: "Module" })), af = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useBreadcrumb: Go,
  useColorMode: qr,
  useModal: Wr,
  useModalController: Ur,
  useToast: tn
}, Symbol.toStringTag, { value: "Module" })), lf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: eo,
  BvEvent: ot,
  BvTriggerableEvent: Ft
}, Symbol.toStringTag, { value: "Module" })), of = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), nf = {
  install(e, t = { components: !0, directives: !0 }) {
    const l = typeof t.components == "boolean" || typeof t.components > "u" ? { all: !0 } : t.components, a = Object.keys(Xl);
    _l(l, a).forEach((s) => {
      const r = Xl[s];
      e.component(s, r);
    });
    const o = typeof (t == null ? void 0 : t.directives) == "boolean" || typeof t.directives > "u" ? { all: !0 } : t == null ? void 0 : t.directives, n = Object.keys(ql);
    _l(o, n).forEach((s) => {
      const r = s.toLowerCase().startsWith("v") ? s.slice(1) : s, i = ql[s];
      e.directive(r, i);
    });
  }
};
export {
  ni as BAccordion,
  ui as BAccordionItem,
  vi as BAlert,
  bi as BAvatar,
  hi as BAvatarGroup,
  Bi as BBadge,
  Ci as BBreadcrumb,
  on as BBreadcrumbItem,
  ut as BButton,
  ki as BButtonGroup,
  _i as BButtonToolbar,
  fn as BCard,
  dn as BCardBody,
  cn as BCardFooter,
  Oi as BCardGroup,
  sn as BCardHeader,
  na as BCardImg,
  un as BCardSubtitle,
  Ei as BCardText,
  rn as BCardTitle,
  xi as BCarousel,
  qi as BCarouselSlide,
  Nt as BCloseButton,
  Lt as BCol,
  ln as BCollapse,
  Ui as BContainer,
  vn as BDropdown,
  Yi as BDropdownDivider,
  eu as BDropdownForm,
  lu as BDropdownGroup,
  nu as BDropdownHeader,
  ru as BDropdownItem,
  du as BDropdownItemButton,
  vu as BDropdownText,
  pn as BForm,
  mn as BFormCheckbox,
  Cu as BFormCheckboxGroup,
  _u as BFormFile,
  yu as BFormFloatingLabel,
  Nu as BFormGroup,
  Iu as BFormInput,
  Va as BFormInvalidFeedback,
  yn as BFormRadio,
  Du as BFormRadioGroup,
  Jt as BFormRow,
  Wu as BFormSelect,
  ll as BFormSelectOption,
  bn as BFormSelectOptionGroup,
  Yu as BFormSpinbutton,
  Cn as BFormTag,
  fd as BFormTags,
  Aa as BFormText,
  pd as BFormTextarea,
  Oa as BFormValidFeedback,
  al as BImg,
  Sd as BInputGroup,
  ol as BInputGroupAddon,
  wd as BInputGroupAppend,
  Cd as BInputGroupPrepend,
  kn as BInputGroupText,
  tt as BLink,
  kd as BListGroup,
  $d as BListGroupItem,
  Ad as BModal,
  Od as BNav,
  Fd as BNavForm,
  Nd as BNavItem,
  Id as BNavItemDropdown,
  zd as BNavText,
  xd as BNavbar,
  Rd as BNavbarBrand,
  Md as BNavbarNav,
  Kd as BNavbarToggle,
  Zd as BOffcanvas,
  nl as BOverlay,
  rc as BPagination,
  ze as BPlaceholder,
  Vn as BPlaceholderButton,
  ic as BPlaceholderCard,
  uc as BPlaceholderTable,
  dc as BPlaceholderWrapper,
  tl as BPopover,
  On as BProgress,
  An as BProgressBar,
  pc as BRow,
  pa as BSpinner,
  Wc as BTab,
  Lc as BTable,
  En as BTableLite,
  sl as BTableSimple,
  Xc as BTabs,
  Ic as BTbody,
  xc as BTd,
  Rc as BTfoot,
  jc as BTh,
  qc as BThead,
  Fn as BToast,
  Zc as BToaster,
  Qc as BTooltip,
  Gc as BTr,
  Pt as BTransition,
  nf as BootstrapVueNext,
  eo as BvCarouselEvent,
  ot as BvEvent,
  Ft as BvTriggerableEvent,
  Xl as Components,
  af as Composables,
  ql as Directives,
  of as Types,
  lf as Utils,
  nf as default,
  Go as useBreadcrumb,
  qr as useColorMode,
  Wr as useModal,
  Ur as useModalController,
  tn as useToast,
  Dd as vBColorMode,
  Pa as vBModal,
  Gd as vBPopover,
  Pa as vBToggle,
  Wd as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
